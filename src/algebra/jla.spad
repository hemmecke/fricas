)abbrev package JRLA JuliaRealLinearAlgebra
++ Linear Algebra functions computed using Julia and its algorithms.
JuliaRealLinearAlgebra() : Exports == Implementation where
    JF64     ==> JuliaFloat64
    JI64     ==> JuliaInt64
    JI64VEC  ==> JuliaInt64Vector
    JF64VEC  ==> JuliaFloat64Vector
    JF64MAT  ==> JuliaFloat64Matrix
    JCF64VEC ==> JuliaComplexF64Vector
    JCF64MAT ==> JuliaComplexF64Matrix
    NNI      ==> NonNegativeInteger
    Exports ==> with
        normalize:  JF64VEC -> JF64VEC
        ++ normalize(v) returns normalized v such that its norm equals to 1.
        normalize!:  JF64VEC -> JF64VEC
        ++ normalize!(v) destructively normalize v such that
        ++ norm(v) equals to 1.
        normalize:  JF64MAT -> JF64MAT
        ++ normalize(m) returns normalized m such that its norm equals to 1.
        normalize!:  JF64MAT -> JF64MAT
        ++ normalize!(m) destructively normalize m such that
        ++ its norm equals to 1.
        norm    : JF64VEC -> JF64
        ++ norm(v) computes the 2-norm of v.
        norm    : (JF64VEC,JF64) -> JF64
        ++ norm(v,p) computes th p-norm of v.
        norm    : JF64MAT -> JF64
        ++ norm(m) computes the 2-norm of m,
        ++ also known as the Frobenius norm.
        norm    : (JF64MAT,JF64) -> JF64
        ++ norm(m,p) computes the p-norm of m.
        operatorNorm    : JF64MAT -> JF64
        ++ operatorNorm(m) computes the operator norm of m
        ++ induced by the vector 2-norm.
        operatorNorm    : (JF64MAT,JF64) -> JF64
        ++ operatorNorm(m,p) computes the operator norm of m
        ++ induced by the vector p-norm.
        conditionNumber    : JF64MAT -> JF64
        ++ conditionNumber(m) computes the condition number of m.
        conditionNumber    : (JF64MAT,JF64) -> JF64
        ++ conditionNumber(m, p) computes the p-condition number of m.
        condSkeel    : JF64MAT -> JF64
        ++ condSkeel(m) computes the Skeel condition number of m.
        trace   : JF64MAT -> JF64
        ++ trace(m) computes the trace of m.
        rank        : (JF64MAT, JF64) -> NNI
        ++ rank(m, tol) computes rank of m. Counts singular value
        ++ with magnitude greater than tol.
        rank!        : (JF64MAT, JF64) -> NNI
        ++ rank!(m, tol) computes rank of m. Counts singular value
        ++ with magnitude greater than tol but overwrites m to save
        ++ memory space.
        logDeterminant    : JF64MAT -> JF64
        ++ logDeterminant(m) computes the logarithm of the determinant of m,
        ++ possibly with more accuracy and avoding nder/overflow.
        svd:    JF64MAT -> Record(U:JF64MAT, sv:JF64VEC, Vt:JF64MAT)
        ++ svd(m) computes the singular value decomposition SVD of m
        ++ such that SVD.U * diagonalMatrix(sv) * SVD.Vt = m.
        svd!:   JF64MAT -> Record(U:JF64MAT, sv:JF64VEC, Vt:JF64MAT)
        ++ svd!(m) is the same as svd(m) but overwites a to save
        ++ memory space.
        svdvals: JF64MAT -> JF64VEC
        ++ svdvals(m) returns the singular values of m.
        svdvals!: JF64MAT -> JF64VEC
        ++ svdvals!(m) returns the singular values of m but overwrites
        ++ m to save memory space.
        eigvals: JF64MAT -> JCF64VEC
        ++ eigvals(m) returns the eigen values of m.
        eigvals!: JF64MAT -> JCF64VEC
        ++ eigvals!(m) returns the eigen values of m but overwrites
        ++ m to save memory space.
        eigvecs: JF64MAT -> JCF64MAT
        ++ eigvecs(m) returns the eigen vectors of m.
        eigen:  JF64MAT -> Record(values:JCF64VEC, vectors:JCF64MAT)
        ++ eigen(m) computes the spectral decomposition of m.
        eigen!:  JF64MAT -> Record(values:JCF64VEC, vectors:JCF64MAT)
        ++ eigen!(m) computes the spectral decomposition of m but overwrites
        ++ m to save memory space.
        eigenSystem:  JF64MAT ->
            Record(values:JCF64VEC, leftVectors:JF64MAT, rightVectors:JF64MAT)
        ++ eigenSystem(m) computes the spectral decomposition of m.
        ++ If the j-th eigenvalue (values) is real, then the left eigenvectors
        ++ u(j) = column(lefVectors,j), the j-th column of lefVectors.
        ++ If the j-th and (j+1)-st eigenvalues form a complex
        ++ conjugate pair, then the left eigenvectors are
        ++ u(j) = column(lefVectors,j) + %i*column(lefVectors,j+1) and
        ++ u(j+1) = column(lefVectors,j) - %i*column((lefVectors,j+1).
        ++ This applieas also to righVectors.
        eigenSystem!:  JF64MAT ->
            Record(values:JCF64VEC, leftVectors:JF64MAT, rightVectors:JF64MAT)
        ++ eigenSystem!(m) computes the spectral decomposition of m but overwrites
        ++ m to save memory space.
        ++ If the j-th eigenvalue (values) is real, then the left eigenvectors
        ++ u(j) = column(lefVectors,j), the j-th column of lefVectors.
        ++ If the j-th and (j+1)-st eigenvalues form a complex
        ++ conjugate pair, then the left eigenvectors are
        ++ u(j) = column(lefVectors,j) + %i*column(lefVectors,j+1) and
        ++ u(j+1) = column(lefVectors,j) - %i*column((lefVectors,j+1).
        ++ This applieas also to righVectors.
        solve : (JF64MAT, JF64MAT) -> JF64MAT
        ++ solve(A,B) solves the matrix equation A*X=B, and returns X.
        solve! : (JF64MAT, JF64MAT) -> JF64MAT
        ++ solve!(A,B) solves the matrix equation A*X=B. Overwrites
        ++ B with matrix X and returns X.
        lu      : JF64MAT -> Record(LU:JF64MAT,
                    L:JF64MAT, U:JF64MAT, ipiv:JI64VEC)
        ++ lu(m) computes the LU factorisation of m.
        lu!     : JF64MAT -> Record(LU:JF64MAT, ipiv:JI64VEC)
        ++ lu!(m) computes the LU factorisation of m in m.
        luReorder : (JF64MAT, JI64VEC) -> JF64MAT
        ++ luOrder(mat, ipiv) returns a copy of mat reordered with ipiv pivot indices.
        luReorder! : (JF64MAT, JI64VEC) -> JF64MAT
        ++ luOrder(mat, ipiv) returns mat in-place reordered with ipiv pivot indices.
        mpInverse : JF64MAT -> JF64MAT
        ++ mpInverse(m) returns the Moore-Penrose pseudo inverse of m.
        sqrt:   JF64MAT -> JCF64MAT
        ++ sqrt(m) returns the principal square root of m.
        exp:   JF64MAT -> JF64MAT
        ++ exp(m) returns the matrix exponential of m.
        log:   JF64MAT -> JCF64MAT
        ++ log(m) tries to compute the principal matrix logarithm of m.
        ++ Otherwise, returns a non pricipal matrix logarithm of m if possible.
        triu    : JF64MAT -> JF64MAT
        ++ triu(m) returns the upper triangular matrix of m.
        triu!   : JF64MAT -> JF64MAT
        ++ triu!(m) overwrites m with its upper triangular matrix counterpart.
        ++ Returns m.
        tril    : JF64MAT -> JF64MAT
        ++ tril(m) returns the lower triangular matrix of m
        tril!   : JF64MAT -> JF64MAT
        ++ tril!(m) overwrites m with its upper triangular matrix counterpart.
        ++ Returns m.
        jlPeakFlops : () -> JF64
        ++ jlPeakFlops() returns the peak flop rate
        ++ using matrix multiplication. You can modify the number of threads
        ++ used or the BLAS/LAPACK libraries used to see if that fits
        ++ your needs. 
    Implementation ==> add
        import from JuliaUtilityFunctions
        jlUsing(coerce("LinearAlgebra"))
        jlImport(coerce("LinearAlgebra.peakflops"))
        jlImport(coerce("LinearAlgebra.LAPACK.gesv!"))
        jlImport(coerce("LinearAlgebra.LAPACK.geev!"))

        jlPeakFlops() == jl_dbl_eval_string("peakflops()")$Lisp

        normalize(v : JF64VEC) ==
            vt := copy(v)
            jl_1dfunction(0$NNI,"normalize!", vt)$Lisp
            vt
        normalize!(v: JF64VEC) == (jl_1dfunction(0$NNI,"normalize!", v)$Lisp;v)
        normalize(m : JF64MAT) ==
            nr := nrows(m)
            mt := qnew(nr, ncols(m))$JF64MAT
            jl_array_2dfunction(0$NNI,0$NNI,"normalize", jlVector(mt),
                jlVector(m), nr)$Lisp
            mt
        normalize!(m: JF64MAT) ==
            jl_2dfunction(0$NNI,"normalize!", jlVector(m), nrows(m))$Lisp
            m

        norm(v : JF64VEC) == jl_dbl_1dfunction(0$NNI,"norm", v)$Lisp
        norm(v : JF64VEC, p:JF64) ==
            jl_dbl_1dfunction_dbl(0$NNI,"norm", v, p)$Lisp
        norm(m : JF64MAT) == jl_dbl_2dfunction(0$NNI, "norm", jlVector(m),
            nrows(m))$Lisp
        norm(m : JF64MAT, p:JF64) == jl_dbl_2dfunction_dbl(0$NNI, "norm", jlVector(m),
            nrows(m), p)$Lisp
        operatorNorm(m : JF64MAT) == jl_dbl_2dfunction(0$NNI, "opnorm", jlVector(m),
            nrows(m))$Lisp
        operatorNorm(m : JF64MAT, p:JF64) == jl_dbl_2dfunction_dbl(0$NNI, "opnorm", jlVector(m),
            nrows(m), p)$Lisp
        conditionNumber(m : JF64MAT) == jl_dbl_2dfunction(0$NNI, "cond", jlVector(m),
            nrows(m))$Lisp
        conditionNumber(m : JF64MAT, p:JF64) == jl_dbl_2dfunction_dbl(0$NNI, "cond", jlVector(m),
            nrows(m), p)$Lisp
        condSkeel(m : JF64MAT) == jl_dbl_2dfunction(0$NNI, "condskeel", jlVector(m),
            nrows(m))$Lisp
        trace(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "trace: matrix is not square"
            jl_dbl_2dfunction(0$NNI, "tr", jlVector(m), nr)$Lisp

        rank(m, tol) : NNI == count(x +-> x > tol, svdvals(m))$JF64VEC
        rank!(m, tol) : NNI == count(x +-> x > tol, svdvals!(m))$JF64VEC

        logDeterminant(m) == jl_dbl_2dfunction(0$NNI, "logdet",
            jlVector(m), nrows(m))$Lisp

        svd_wrapper: (String, JF64MAT) -> Record(U:JF64MAT, sv:JF64VEC, Vt:JF64MAT)
        svd_wrapper(func, a) ==
            u, vt : JF64MAT
            sv : JF64VEC
            nr := nrows(a)
            nc := ncols(a)
            sv := qnew(min(nr,nc))$JF64VEC
            if nr < nc then
                u  := qnew(nr, nr)
                vt := qnew(nr, nc)
            else if nr > nc then
                u  := qnew(nr, nc)
                vt := qnew(nc, nc)
            else 
                u  := qnew(nr, nc)
                vt := qnew(nr,nc)
            jl_svd_function(0$NNI, func, jlVector(u), sv, jlVector(vt),
                jlVector(a), nr)$Lisp
            [u,sv,vt]

        svd(a) == svd_wrapper("svd", a)

        svd!(a) == svd_wrapper("svd!", a)

        svdvals(a) ==
            m := nrows(a)
            n := ncols(a)
            v := qnew(min(m,n))$JF64VEC
            jl_array_2dfunction(0$NNI,0$NNI,"svdvals", v, jlVector(a), m)$Lisp
            v

        svdvals!(a) ==
            m := nrows(a)
            n := ncols(a)
            v := qnew(min(m,n))$JF64VEC
            jl_array_2dfunction(0$NNI,0$NNI,"svdvals!", v, jlVector(a), m)$Lisp
            v
        
        eigvals(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "eigvals: matrix is not square"
            v := qnew(m)$JCF64VEC
            jl_array_2dfunction(1$NNI,0$NNI,"eigvals", v, jlVector(a), m)$Lisp
            v

        eigvals!(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "eigvals!: matrix is not square"
            v := qnew(m)$JCF64VEC
            jl_array_2dfunction(1$NNI,0$NNI,"eigvals!", v, jlVector(a), m)$Lisp
            v

        eigvecs(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "eigvecs: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"eigvecs", jlVector(ret),
                jlVector(a), m)$Lisp
            ret
            
        eigen(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigen: matrix is not square"
            vecs := qnew(m,m)$JCF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_function(0$NNI, "eigen", vals, jlVector(vecs),
                    jlVector(a), m)$Lisp
            [vals,vecs]

        eigen!(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigen!: matrix is not square"
            vecs := qnew(m,m)$JCF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_function(0$NNI, "eigen!", vals, jlVector(vecs),
                    jlVector(a), m)$Lisp
            [vals,vecs]

        eigenSystem(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigenSystem: matrix is not square"
            ca := copy a
            lvecs := qnew(m,m)$JF64MAT
            rvecs := qnew(m,m)$JF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_system_function(0$NNI, "geev!", vals, jlVector(lvecs),
                    jlVector(rvecs), jlVector(ca), m)$Lisp
            [vals,lvecs,rvecs]

        eigenSystem!(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigenSystem!: matrix is not square"
            lvecs := qnew(m,m)$JF64MAT
            rvecs := qnew(m,m)$JF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_system_function(0$NNI, "geev!", vals, jlVector(lvecs),
                    jlVector(rvecs), jlVector(a), m)$Lisp
            [vals,lvecs,rvecs]

        solve(a,b) ==
            aa := copy a
            bb := copy b
            jl_2d2function(0$NNI,"gesv!", jlVector(aa), nrows(aa),
                jlVector(bb), nrows(bb))$Lisp
            bb

        solve!(a,b) ==
            aa := copy a
            jl_2d2function(0$NNI,"gesv!", jlVector(aa), nrows(aa),
                jlVector(b), nrows(b))$Lisp
            b

        mpInverse(a) ==
            mpinv := qnew(ncols(a), nrows(a))$JF64MAT
            jl_array_2dfunction(0$NNI,0$NNI,"pinv", jlVector(mpinv),
                jlVector(a), nrows(a))$Lisp
            mpinv

        sqrt(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "sqrt: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"sqrt", jlVector(ret), jlVector(a), m)$Lisp
            ret

        exp(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "exp: matrix is not square"
            ret := qnew(m,m)
            jl_array_2dfunction(0$NNI,0$NNI,"exp", jlVector(ret), jlVector(a), m)$Lisp
            ret

        log(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "log: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"log", jlVector(ret), jlVector(a), m)$Lisp
            ret

        -- local
        ldiv!   : (JF64MAT, JF64MAT) -> JF64MAT
        rdiv!   : (JF64MAT, JF64MAT) -> JF64MAT

        lu(a) ==
            m    := nrows(a)
            n    := ncols(a)
            mn   := min(m,n)
            lu   := qnew(m,n)$JF64MAT
            l    := new(m, mn, 0)$JF64MAT
            u    := new(mn, n, 0)$JF64MAT
            ipiv := qnew(mn)$JI64VEC
            copy!(lu,a)
            jl_iarray_2dfunction(0$NNI,"lu!", ipiv, jlVector(lu),m)$Lisp            
            for i in 1 .. m repeat
                for j in 1 .. n repeat
                    if j < i then
                        setelt!(l, i, j, qelt(lu,i, j))
                    else if j > i then
                        setelt!(u, i, j, qelt(lu, i, j))
                    else
                        setelt!(u, i, j, qelt(lu, i, j))
                        setelt!(l, i, j, 1)
            [lu, l, u, ipiv]

        lu!(a) ==
            m := nrows(a)
            n := ncols(a)
            ipiv := qnew(min(m,n))$JI64VEC
            jl_iarray_2dfunction(0$NNI,"lu!", ipiv, jlVector(a), m)$Lisp
            [a, ipiv]
        
        luReorder(mat, ipiv) : JF64MAT == luReorder!(copy(mat), ipiv)

        luReorder!(mat, ipiv) : JF64MAT ==
            n := #ipiv
            for i in 1..n repeat
                swapRows!(mat, i, qelt(ipiv, i) pretend Integer)
            mat

        ldiv!(a, b) ==
            c := qnew(nrows(a), ncols(b))
            jl_2d3function(0$NNI,"ldiv!", jlVector(c), nrows(c),
                jlVector(a), nrows(a), jlVector(b), nrows(b))$Lisp
            c

        rdiv!(a, b) ==
            c := qnew(nrows(a), ncols(b))
            jl_2d3function(0$NNI,"rdiv!", jlVector(c), nrows(c),
                jlVector(a), nrows(a), jlVector(b), nrows(b))$Lisp
            c

        triu(m) ==
            mm := copy m
            jl_2dfunction(0$NNI,"triu!", jlVector(mm),
                nrows(mm))$Lisp
            mm

        triu!(m) ==
            jl_2dfunction(0$NNI,"triu!", jlVector(m),
                nrows(m))$Lisp
            m

        tril(m) ==
            mm := copy m
            jl_2dfunction(0$NNI,"tril!", jlVector(mm),
                nrows(mm))$Lisp
            mm

        tril!(m) ==
            jl_2dfunction(0$NNI,"tril!", jlVector(m),
                nrows(m))$Lisp
            m

)abbrev package JCLA JuliaComplexLinearAlgebra
++ Linear Algebra functions computed using Julia and its algorithms.
JuliaComplexLinearAlgebra() : Exports == Implementation where
    JF64     ==> JuliaFloat64
    JI64     ==> JuliaInt64
    JF64VEC  ==> JuliaFloat64Vector
    JF64MAT  ==> JuliaFloat64Matrix
    JCF64VEC ==> JuliaComplexF64Vector
    JCF64MAT ==> JuliaComplexF64Matrix
    NNI      ==> NonNegativeInteger
    Exports ==> with
        normalize:  JCF64VEC -> JCF64VEC
        ++ normalize(v) returns normalized v such that its norm equals to 1.
        normalize!:  JCF64VEC -> JCF64VEC
        ++ normalize!(v) destructively normalize v such that
        ++ norm(v) equals to 1.
        normalize:  JCF64MAT -> JCF64MAT
        ++ normalize(m) returns normalized m such that its norm equals to 1.
        normalize!:  JCF64MAT -> JCF64MAT
        ++ normalize!(m) destructively normalize m such that
        ++ its norm equals to 1.
        norm    : JCF64VEC -> JF64
        ++ norm(v) computes the 2-norm of v.
        norm    : (JCF64VEC,JF64) -> JF64
        ++ norm(v,p) computes th p-norm of v.
        norm    : JCF64MAT -> JF64
        ++ norm(m) computes the 2-norm of m,
        ++ also known as the Frobenius norm.
        norm    : (JCF64MAT,JF64) -> JF64
        ++ norm(m,p) computes the p-norm of m.
        operatorNorm    : JCF64MAT -> JF64
        ++ operatorNorm(m) computes the operator norm of m
        ++ induced by the vector 2-norm.
        operatorNorm    : (JCF64MAT,JF64) -> JF64
        ++ operatorNorm(m,p) computes the operator norm of m
        ++ induced by the vector p-norm.
        conditionNumber    : JCF64MAT -> JF64
        ++ conditionNumber(m) computes the condition number of m.
        conditionNumber    : (JCF64MAT,JF64) -> JF64
        ++ conditionNumber(m) computes the p-condition number of m.
        condSkeel    : JCF64MAT -> JF64
        ++ condsKeel(m) computes the Skeel condition number of m.
        rank        : (JCF64MAT, JF64) -> NNI
        ++ rank(m, tol) computes rank of m. Counts singular value
        ++ with magnitude greater than tol.
        rank!        : (JCF64MAT, JF64) -> NNI
        ++ rank!(m, tol) computes rank of m. Counts singular value
        ++ with magnitude greater than tol but overwrites m to save
        ++ memory space.
        solve : (JCF64MAT, JCF64MAT) -> JCF64MAT
        ++ solve(A,B) solves the matrix equation A*X=B, and returns X.
        solve! : (JCF64MAT, JCF64MAT) -> JCF64MAT
        ++ solve!(A,B) solves the matrix equation A*X=B. Overwrites
        ++ B with matrix X and returns X.
        svd:    JCF64MAT -> Record(U:JCF64MAT, sv:JF64VEC, Vt:JCF64MAT)
        ++ svd(m) computes the singular value decomposition SVD of m
        ++ such that SVD.U * diagonalMatrix(sv) * SVD.Vt = m.
        svd!:   JCF64MAT -> Record(U:JCF64MAT, sv:JF64VEC, Vt:JCF64MAT)
        ++ svd!(m) is the same as svd(m) but overwites a to save
        ++ memory space.
        eigen:  JCF64MAT -> Record(values:JCF64VEC, vectors:JCF64MAT)
        ++ eigen(m) computes the spectral decomposition of m.
        eigen!:  JCF64MAT -> Record(values:JCF64VEC, vectors:JCF64MAT)
        ++ eigen!(m) computes the spectral decomposition of m but overwrites
        ++ m to save memory space.
        eigenSystem:  JCF64MAT ->
            Record(values:JCF64VEC, leftVectors:JCF64MAT, rightVectors:JCF64MAT)
        ++ eigenSystem(m) computes the spectral decomposition of m.
        eigenSystem!:  JCF64MAT ->
            Record(values:JCF64VEC, leftVectors:JCF64MAT, rightVectors:JCF64MAT)
        ++ eigenSystem!(m) computes the spectral decomposition of m but overwrites
        ++ m to save memory space.
        svdvals: JCF64MAT -> JF64VEC
        ++ svdvals(m) returns the singular values of m.
        svdvals!: JCF64MAT -> JF64VEC
        ++ svdvals!(m) returns the singular values of m but overwrites
        ++ m to save memory space.
        eigvals: JCF64MAT -> JCF64VEC
        ++ eigvals(m) returns the eigen values of m.
        eigvals!: JCF64MAT -> JCF64VEC
        ++ eigvals!(m) returns the eigen values of m but overwrites
        ++ m to save memory space.
        eigvecs: JCF64MAT -> JCF64MAT
        ++ eigvecs(m) returns the eigen vectors of m.
        mpInverse : JCF64MAT -> JCF64MAT
        ++ mpInverse(m) returns the Moore-Penrose pseudo inverse of m.
        sqrt:   JCF64MAT -> JCF64MAT
        ++ sqrt(m) returns the principal square root of m.
        exp:   JCF64MAT -> JCF64MAT
        ++ exp(m) returns the matrix exponential of m.
        log:   JCF64MAT -> JCF64MAT
        ++ log(m) tries to compute the principal matrix logarithm of m.
        ++ Otherwise, returns a non pricipal matrix logarithm of m if possible.
    Implementation ==> add
        import from JuliaUtilityFunctions
        jlUsing(coerce("LinearAlgebra"))
        jlImport(coerce("LinearAlgebra.LAPACK.gesv!"))
        jlImport(coerce("LinearAlgebra.LAPACK.geev!"))


        normalize(v : JCF64VEC) ==
            vtmp := copy(v)
            jl_1dfunction(1$NNI,"normalize!", vtmp)$Lisp
            vtmp

        normalize!(v: JCF64VEC) == (jl_1dfunction(1$NNI,"normalize!", v)$Lisp;v)

        normalize(m : JCF64MAT) ==
            nr := nrows(m)
            mtmp := qnew(nr, ncols(m))$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"normalize", jlVector(mtmp),
                jlVector(m), nr)$Lisp
            mtmp

        normalize!(m: JCF64MAT) ==
            jl_2dfunction(1$NNI,"normalize!", jlVector(m), nrows(m))$Lisp
            m

        norm(v : JCF64VEC) == jl_dbl_1dfunction(1$NNI,"norm", v)$Lisp
        norm(v : JCF64VEC, p:JF64) ==
            jl_dbl_1dfunction_dbl(1$NNI,"norm", v, p)$Lisp
        norm(m : JCF64MAT) == jl_dbl_2dfunction(1$NNI, "norm", jlVector(m),
            nrows(m))$Lisp
        norm(m : JCF64MAT, p:JF64) == jl_dbl_2dfunction_dbl(1$NNI, "norm",
            jlVector(m), nrows(m), p)$Lisp
        operatorNorm(m : JCF64MAT) == jl_dbl_2dfunction(1$NNI, "opnorm", jlVector(m),
            nrows(m))$Lisp
        operatorNorm(m : JCF64MAT, p:JF64) == jl_dbl_2dfunction_dbl(1$NNI, "opnorm", jlVector(m),
            nrows(m), p)$Lisp
        conditionNumber(m : JCF64MAT) == jl_dbl_2dfunction(1$NNI, "cond", jlVector(m),
            nrows(m))$Lisp
        conditionNumber(m : JCF64MAT, p:JF64) == jl_dbl_2dfunction_dbl(1$NNI, "cond", jlVector(m),
            nrows(m), p)$Lisp
        condSkeel(m : JCF64MAT) == jl_dbl_2dfunction(1$NNI, "condskeel", jlVector(m),
            nrows(m))$Lisp

        rank(m, tol) : NNI == count(x +-> x > tol, svdvals(m))$JF64VEC
        rank!(m, tol): NNI == count(x +-> x > tol, svdvals!(m))$JF64VEC

        solve(a,b) ==
            aa := copy(a)
            bb := copy(b)
            jl_2d2function(1$NNI,"gesv!", jlVector(aa), nrows(aa),
                jlVector(bb), nrows(bb))$Lisp
            bb

        solve!(a,b) ==
            aa := copy(a)
            jl_2d2function(1$NNI,"gesv!", jlVector(aa), nrows(aa),
                jlVector(b), nrows(b))$Lisp
            b

        mpInverse(a) ==
            mpinv := qnew(ncols(a), nrows(a))$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"pinv", jlVector(mpinv),
                jlVector(a), nrows(a))$Lisp
            mpinv

        svdvals(a) ==
            m := nrows(a)
            n := ncols(a)
            v := qnew(min(m,n))$JF64VEC
            jl_array_2dfunction(0$NNI,1$NNI,"svdvals", v, jlVector(a), m)$Lisp
            v

        svdvals!(a) ==
            m := nrows(a)
            n := ncols(a)
            v := qnew(min(m,n))$JF64VEC
            jl_array_2dfunction(0$NNI,1$NNI,"svdvals!", v, jlVector(a), m)$Lisp
            v
        
        eigvals(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "eigvals: matrix is not square"
            v := qnew(m)$JCF64VEC
            jl_array_2dfunction(1$NNI,1$NNI,"eigvals", v, jlVector(a), m)$Lisp
            v

        eigvals!(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "eigvals!: matrix is not square"
            v := qnew(m)$JCF64VEC
            jl_array_2dfunction(1$NNI,1$NNI,"eigvals!", v, jlVector(a), m)$Lisp
            v

        eigvecs(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "eigvecs: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"eigvecs", jlVector(ret), jlVector(a), m)$Lisp
            ret

        svd_wrapper: (String, JCF64MAT) -> Record(U:JCF64MAT, sv:JF64VEC, Vt:JCF64MAT)
        svd_wrapper(func, a) ==
            u, vt : JCF64MAT
            sv : JF64VEC
            nr := nrows(a)
            nc := ncols(a)
            sv := qnew(min(nr,nc))$JF64VEC
            if nr < nc then
                u  := qnew(nr, nr)$JCF64MAT
                vt := qnew(nr, nc)$JCF64MAT
            else if nr > nc then
                u  := qnew(nr, nc)$JCF64MAT
                vt := qnew(nc, nc)$JCF64MAT
            else 
                u  := qnew(nr, nc)$JCF64MAT
                vt := qnew(nr, nc)$JCF64MAT
            jl_svd_function(1$NNI, func, jlVector(u), sv, jlVector(vt),
                jlVector(a), nr)$Lisp
            [u,sv,vt]

        svd(a) == svd_wrapper("svd", a)

        svd!(a) == svd_wrapper("svd!", a)

        eigen(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigen: matrix is not square"
            vecs := qnew(m,m)$JCF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_function(1$NNI, "eigen", vals, jlVector(vecs),
                    jlVector(a), m)$Lisp
            [vals,vecs]

        eigen!(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigen!: matrix is not square"
            vecs := qnew(m,m)$JCF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_function(1$NNI, "eigen!", vals, jlVector(vecs),
                    jlVector(a), m)$Lisp
            [vals,vecs]

        eigenSystem(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigenSystem: matrix is not square"
            ca := copy a
            lvecs := qnew(m,m)$JCF64MAT
            rvecs := qnew(m,m)$JCF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_system_function(1$NNI, "geev!", vals, jlVector(lvecs),
                    jlVector(rvecs), jlVector(ca), m)$Lisp
            [vals,lvecs,rvecs]

        eigenSystem!(a) == 
            m := nrows(a)
            m ~= ncols(a) => error "eigenSystem!: matrix is not square"
            lvecs := qnew(m,m)$JCF64MAT
            rvecs := qnew(m,m)$JCF64MAT
            vals := qnew(m)$JCF64VEC
            jl_eigen_system_function(1$NNI, "geev!", vals, jlVector(lvecs),
                    jlVector(rvecs), jlVector(a), m)$Lisp
            [vals,lvecs,rvecs]

        sqrt(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "sqrt: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"sqrt", jlVector(ret), jlVector(a), m)$Lisp
            ret

        exp(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "exp: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"exp", jlVector(ret), jlVector(a), m)$Lisp
            ret

        log(a) ==
            m := nrows(a)
            m ~= ncols(a) => error "log: matrix is not square"
            ret := qnew(m,m)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"log", jlVector(ret), jlVector(a), m)$Lisp
            ret

)abbrev package JF64MTF JuliaF64MatrixTranscendentalFunctions
++ Linear Algebra functions computed using Julia and its algorithms.
JuliaF64MatrixTranscendentalFunctions() : Exports == Implementation where
    JF64     ==> JuliaFloat64
    JI64     ==> JuliaInt64
    JF64VEC  ==> JuliaFloat64Vector
    JF64MAT  ==> JuliaFloat64Matrix
    JCF64VEC ==> JuliaComplexF64Vector
    JCF64MAT ==> JuliaComplexF64Matrix
    NNI      ==> NonNegativeInteger
    Exports ==> with
        sin   : JF64MAT -> JF64MAT
        ++ sin(m) computes the matrix sine of m.
        sind  : JF64MAT -> JF64MAT
        ++ sind(m) computes the matrix sine of m, where m is in degrees.
        cos   : JF64MAT -> JF64MAT
        ++ cos(m) computes the matrix cosine of m.
        cosd  : JF64MAT -> JF64MAT
        ++ cosd(m) computes the matrix cosine of m, where m is in degrees.
        tan   : JF64MAT -> JF64MAT
        ++ tan(m) computes the matrix tangent of m.
        tand   : JF64MAT -> JF64MAT
        ++ tand(m) computes the matrix tangent of m, where m is in degrees.
        sec   : JF64MAT -> JF64MAT
        ++ sec(m) computes the matrix secant of m.
        csc   : JF64MAT -> JF64MAT
        ++ csc(m) computes the matrix cosecant of m.
        cot   : JF64MAT -> JF64MAT
        ++ cot(m) computes the matrix cotangent of m.
        sinh   : JF64MAT -> JF64MAT
        ++ sinh(m) computes the matrix hyperbolic sine of m.
        cosh   : JF64MAT -> JF64MAT
        ++ cosh(m) computes the matrix hyperbolic cosine of m.
        tanh   : JF64MAT -> JF64MAT
        ++ tanh(m) computes the matrix hyperbolic tangent of m.
        sech   : JF64MAT -> JF64MAT
        ++ sech(m) computes the matrix hyperbolic secant of m.
        csch   : JF64MAT -> JF64MAT
        ++ csch(m) computes the matrix hyperbolic cosecant of m.
        coth   : JF64MAT -> JF64MAT
        ++ coth(m) computes the matrix hyperbolic cotangent of m.
        asin   : JF64MAT -> JCF64MAT
        ++ asin(m) computes the inverse matrix sine of m.
        asind   : JF64MAT -> JCF64MAT
        ++ asind(m) computes the inverse matrix sine of m. Output is in degrees.
        acos   : JF64MAT -> JCF64MAT
        ++ acos(m) computes the inverse matrix cosine of m.
        acosd   : JF64MAT -> JCF64MAT
        ++ acosd(m) computes the inverse matrix cosine of m. Output is in degrees.
        atan   : JF64MAT -> JCF64MAT
        ++ atan(m) computes the inverse matrix tangent of m.
        atand   : JF64MAT -> JCF64MAT
        ++ atand(m) computes the inverse matrix tangent of m. Output is in degrees.
        asec   : JF64MAT -> JCF64MAT
        ++ asec(m) computes the inverse matrix secant of m.
        asecd   : JF64MAT -> JCF64MAT
        ++ asecd(m) computes the inverse matrix secant of m. Output is in degrees.
        acsc   : JF64MAT -> JCF64MAT
        ++ acsc(m) computes the inverse matrix cosecant of m.
        acscd   : JF64MAT -> JCF64MAT
        ++ acscd(m) computes the inverse matrix cosecant of m. Output is in degrees.
        acot   : JF64MAT -> JCF64MAT
        ++ acot(m) computes the inverse matrix cotangent of m.
        acotd   : JF64MAT -> JCF64MAT
        ++ acotd(m) computes the inverse matrix cotangent of m. Output is in degrees.
        asinh   : JF64MAT -> JCF64MAT
        ++ asinh(m) computes the inverse matrix hyperbolic sine of m.
        acosh   : JF64MAT -> JCF64MAT
        ++ acosh(m) computes the inverse matrix hyperbolic cosine of m.
        atanh   : JF64MAT -> JCF64MAT
        ++ atanh(m) computes the inverse matrix hyperbolic tangent of m.
        asech   : JF64MAT -> JCF64MAT
        ++ asech(m) computes the inverse matrix hyperbolic secant of m.
        acsch   : JF64MAT -> JCF64MAT
        ++ acsch(m) computes the inverse matrix hyperbolic cosecant of m.
        acoth   : JF64MAT -> JCF64MAT
        ++ acoth(m) computes the inverse matrix hyperbolic cotangent of m.
    Implementation ==> add
        import from JuliaUtilityFunctions
        jlUsing(coerce("LinearAlgebra"))

        sin(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sin: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"sin", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sind(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sind: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"sind", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cos(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cos: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"cos", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cosd(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cosd: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"cosd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        tan(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "tan: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"tan", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        tand(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "tand: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"tand", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sec(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sec: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"sec", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        csc(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "csc: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"csc", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cot(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cot: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"cot", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sinh(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sinh: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"sinh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cosh(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cosh: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"cosh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        tanh(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "tanh: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"tanh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sech(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sech: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"sech", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        csch(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "csch: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"csch", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        coth(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "coth: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(0$NNI,0$NNI,"coth", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asin(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asin: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"asin", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asind(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asind: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"asind", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acos(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acos: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acos", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acosd(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acosd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acosd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        atan(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "atan: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"atan", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        atand(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "atand: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"atand", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asec(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asec: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"asec", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asecd(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asecd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"asecd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acsc(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acsc: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acsc", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acscd(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acscd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acscd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acot(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acot: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acot", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acotd(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acotd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acotd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asinh(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asinh: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"asinh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acosh(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acosh: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acosh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        atanh(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "atanh: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"atanh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asech(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asech: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"asech", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acsch(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acsch: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acsch", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acoth(m : JF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acoth: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,0$NNI,"acoth", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

)abbrev package JCF64MTF JuliaComplexF64MatrixTranscendentalFunctions
++ Linear Algebra functions computed using Julia and its algorithms.
JuliaComplexF64MatrixTranscendentalFunctions() : Exports == Implementation where
    JF64     ==> JuliaFloat64
    JI64     ==> JuliaInt64
    JCF64MAT ==> JuliaComplexF64Matrix
    NNI      ==> NonNegativeInteger
    Exports ==> with
        sin   : JCF64MAT -> JCF64MAT
        ++ sin(m) computes the matrix sine of m.
        sind  : JCF64MAT -> JCF64MAT
        ++ sind(m) computes the matrix sine of m, where m is in degrees.
        cos   : JCF64MAT -> JCF64MAT
        ++ cos(m) computes the matrix cosine of m.
        cosd  : JCF64MAT -> JCF64MAT
        ++ cosd(m) computes the matrix cosine of m, where m is in degrees.
        tan   : JCF64MAT -> JCF64MAT
        ++ tan(m) computes the matrix tangent of m.
        tand  : JCF64MAT -> JCF64MAT
        ++ tand(m) computes the matrix tangent of m, where m is in degrees.
        sec   : JCF64MAT -> JCF64MAT
        ++ sec(m) computes the matrix secant of m.
        csc   : JCF64MAT -> JCF64MAT
        ++ csc(m) computes the matrix cosecant of m.
        cot   : JCF64MAT -> JCF64MAT
        ++ cot(m) computes the matrix cotangent of m.
        sinh  : JCF64MAT -> JCF64MAT
        ++ sinh(m) computes the matrix hyperbolic sine of m.
        cosh  : JCF64MAT -> JCF64MAT
        ++ cosh(m) computes the matrix hyperbolic cosine of m.
        tanh  : JCF64MAT -> JCF64MAT
        ++ tanh(m) computes the matrix hyperbolic tangent of m.
        sech  : JCF64MAT -> JCF64MAT
        ++ sech(m) computes the matrix hyperbolic secant of m.
        csch  : JCF64MAT -> JCF64MAT
        ++ csch(m) computes the matrix hyperbolic cosecant of m.
        coth  : JCF64MAT -> JCF64MAT
        ++ coth(m) computes the matrix hyperbolic cotangent of m.
        asin  : JCF64MAT -> JCF64MAT
        ++ asin(m) computes the inverse matrix sine of m.
        asind : JCF64MAT -> JCF64MAT
        ++ asind(m) computes the inverse matrix sine of m. Output is in degrees.
        acos  : JCF64MAT -> JCF64MAT
        ++ acos(m) computes the inverse matrix cosine of m.
        acosd : JCF64MAT -> JCF64MAT
        ++ acosd(m) computes the inverse matrix cosine of m. Output is in degrees.
        atan  : JCF64MAT -> JCF64MAT
        ++ atan(m) computes the inverse matrix tangent of m.
        atand : JCF64MAT -> JCF64MAT
        ++ atand(m) computes the inverse matrix tangent of m. Output is in degrees.
        asec  : JCF64MAT -> JCF64MAT
        ++ asec(m) computes the inverse matrix secant of m.
        asecd : JCF64MAT -> JCF64MAT
        ++ asecd(m) computes the inverse matrix secant of m. Output is in degrees.
        acsc  : JCF64MAT -> JCF64MAT
        ++ acsc(m) computes the inverse matrix cosecant of m.
        acscd : JCF64MAT -> JCF64MAT
        ++ acscd(m) computes the inverse matrix cosecant of m. Output is in degrees.
        acot  : JCF64MAT -> JCF64MAT
        ++ acot(m) computes the inverse matrix cotangent of m.
        acotd : JCF64MAT -> JCF64MAT
        ++ acotd(m) computes the inverse matrix cotangent of m. Output is in degrees.
        asinh : JCF64MAT -> JCF64MAT
        ++ asinh(m) computes the inverse matrix hyperbolic sine of m.
        acosh : JCF64MAT -> JCF64MAT
        ++ acosh(m) computes the inverse matrix hyperbolic cosine of m.
        atanh : JCF64MAT -> JCF64MAT
        ++ atanh(m) computes the inverse matrix hyperbolic tangent of m.
        asech : JCF64MAT -> JCF64MAT
        ++ asech(m) computes the inverse matrix hyperbolic secant of m.
        acsch : JCF64MAT -> JCF64MAT
        ++ acsch(m) computes the inverse matrix hyperbolic cosecant of m.
        acoth : JCF64MAT -> JCF64MAT
        ++ acoth(m) computes the inverse matrix hyperbolic cotangent of m.
    Implementation ==> add
        import from JuliaUtilityFunctions
        jlUsing(coerce("LinearAlgebra"))

        sin(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sin: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"sin", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sind(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sind: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"sind", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cos(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cos: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"cos", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cosd(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cosd: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"cosd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        tan(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "tan: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"tan", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        tand(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "tand: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"tand", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sec(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sec: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"sec", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        csc(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "csc: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"csc", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cot(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cot: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"cot", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sinh(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sinh: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"sinh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        cosh(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "cosh: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"cosh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        tanh(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "tanh: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"tanh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        sech(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "sech: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"sech", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        csch(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "csch: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"csch", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        coth(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "coth: matrix is not square"
            ret := qnew(nr,nr)
            jl_array_2dfunction(1$NNI,1$NNI,"coth", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asin(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asin: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"asin", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asind(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asind: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"asind", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acos(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acos: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acos", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acosd(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acosd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acosd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        atan(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "atan: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"atan", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        atand(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "atand: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"atand", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asec(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asec: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"asec", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asecd(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asecd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"asecd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acsc(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acsc: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acsc", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acscd(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acscd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acscd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acot(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acot: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acot", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acotd(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acotd: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acotd", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asinh(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asinh: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"asinh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acosh(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acosh: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acosh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        atanh(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "atanh: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"atanh", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        asech(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "asech: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"asech", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acsch(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acsch: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acsch", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret

        acoth(m : JCF64MAT) ==
            nr := nrows(m)
            nr ~= ncols(m) => error "acoth: matrix is not square"
            ret := qnew(nr,nr)$JCF64MAT
            jl_array_2dfunction(1$NNI,1$NNI,"acoth", jlVector(ret),
                jlVector(m), nr)$Lisp
            ret
