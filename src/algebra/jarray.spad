)abbrev category JMATCAT JuliaMatrixCategory
++ Description: This category provides Julia matrices.
JuliaMatrixCategory(R : AbelianMonoid, 
        Row : FiniteLinearAggregate R,
        Col : FiniteLinearAggregate R) : Category == 
            Join(JuliaType, MatrixCategory(R, Row, Col))

)abbrev category JVECCAT JuliaVectorCategory
++ Description: This category provides Julia vectors.
JuliaVectorCategory(R : Type) : Category ==
            Join(JuliaType, VectorCategory(R))

)abbrev domain JI64VEC JuliaInt64Vector
++ Description: This domain provides a fast JuliaFloat64 vector type
++ with no bound checking on elt's. Minimum index is 1.
JuliaInt64Vector() : Exports == Implementation where
    JI64            ==> JuliaInt64
    Qnew            ==> make_int64_array1$Lisp
    Qnew1           ==> make_int64_iarray1$Lisp
    Qsize           ==> INT64VSIZE$Lisp
    Qelt            ==> INT64AREF11$Lisp
    Qsetelt         ==> INT64SETAREF11$Lisp
    Exports == JuliaVectorCategory(JuliaInt64) with
        qnew    : NonNegativeInteger -> %
        ++ qnew(n) returns an unitialized vector of dimension n.
        vector  : List JI64 -> %
        ++ vector(l) converts the list l to a vector.
        jlDisplay: % -> Void
        ++ jlDisplay(v) pretty prints v (à la Julia).
        juliaIVPrint : Boolean -> Boolean
        ++ juliaIVPrint(b) defines whether or not FriCAS uses 
        ++ the printing version of Julia for vectors instead of
        ++ its OutputForm version. Returns previous value.
        ++ By default it is the Julia version.
    Implementation ==> add
        pprint := true

        #x                          == Qsize x
        minIndex x                  == 1$Lisp
        maxIndex x                  == Qsize(x)
        empty()                     == Qnew(0$Lisp)
        qnew(n)                     == Qnew(n)
        new(n, x:JI64)              == Qnew1(n, x)
        qelt(x, i)                  == Qelt(x, i)
        elt(x, i:Integer) : JI64    == Qelt(x, i)
        qsetelt!(x, i, s:JI64)      == Qsetelt(x, i, s)
        setelt!(x : %, i : Integer, s : JI64) == Qsetelt(x, i, s)
        fill!(v, x)       == (for i in 1..Qsize v repeat Qsetelt(v, i, x); v)
        less?(v,n) == #v < n
        vector l == construct l
        coerce(x) : OutputForm      ==
            ~pprint =>
                bracket [qelt(x, k)::OutputForm for k in 1$Lisp .. maxIndex x]
            jlDisplay(x)
            message("Julia Output")

        juliaIVPrint(b) ==
            oldpprint := pprint
            pprint:=b
            oldpprint

        jlDisplay(v) == jl_1difunction("display", v)$Lisp

)abbrev domain JF64VEC JuliaFloat64Vector
++ Description: This domain provides a fast JuliaFloat64 vector type
++ with no bound checking on elt's. Minimum index is 1.
JuliaFloat64Vector() : Exports == Implementation where
    NNI             ==> NonNegativeInteger
    JF64            ==> JuliaFloat64
    Qnew            ==> make_df_array1$Lisp
    Qnew1           ==> make_df_iarray1$Lisp
    Qsize           ==> DFVSIZE$Lisp
    Qelt            ==> DFAREF11$Lisp
    Qsetelt         ==> DFSETAREF11$Lisp
    Exports ==> JuliaVectorCategory(JuliaFloat64) with
        coerce  : % -> DoubleFloatVector
        ++ coerce(v) coerces a copy of v to a DoubleFloatVector.
        coerce! : % -> DoubleFloatVector
        ++ coerce!(v) coerces v to a DoubleFloatVector.
        vector  : List JF64 -> %
        ++ vector(l) converts the list l to a vector.
        qnew    : NonNegativeInteger -> %
        ++ qnew(n) returns an unitialized vector of dimension n.
        copy!: (%, %) -> %
        ++ copy!(b,a) copies efficiently a to b. No check are done on
        ++ arrays dimension.
        jlApply : (JuliaString, %) -> Void
        ++ jlApply(func, v) applies func to argument v.
        jlApply : (JuliaString, %) -> JF64
        ++ jlApply(func, v) applies func to argument v
        ++ and returns a Julia Float64.
        jlApply : (JuliaString, %, JF64) -> JF64
        ++ jlApply(func, v, val) applies func to arguments v and val
        ++ and returns a Julia Float64.
        jlApply : (JuliaString, %, %) -> Void
        ++ jlApply(func, v1, v2) applies func to arguments v1 and v2.
        jlApply : (JuliaString, %, %, %) -> Void
        ++ jlApply(func, v1, v2, v3) applies func to
        ++ arguments v1, v2 and v3.
        urand   :   (NNI, JF64) -> %
        ++ urand(n, x) returns a uniform(0$NNI..x) Julia vector of size n.
        urand01 :   NNI -> %
        ++ urand01(n) returns a uniform(0$NNI..1) Julia vector of size n.
        nrand :   NNI -> %
        ++ nrand(n) returns a normally distributed Julia vector of size n
        ++ with mean=0 and standard deviation=1.
        jlDisplay: % -> Void
        ++ jldisplay(v) pretty prints v (à la Julia).
        juliaVPrint : Boolean -> Boolean
        ++ juliaVPrint(b) defines whether or not FriCAS uses 
        ++ the printing version of Julia for vectors instead of
        ++ its OutputForm version. Returns previous value.
        ++ By default it is the Julia version.
    Implementation ==> add
        import from JuliaUtilityFunctions
        defined?(func) ==>
            not jlDefined?(func) =>
                error concat(string(func), " is not defined in Julia")
        pprint := true

        #x                          == Qsize x
        minIndex x                  == 1$Lisp
        maxIndex x                  == Qsize(x)
        empty()                     == Qnew(0$Lisp)
        qnew(n)                     == Qnew(n)
        new(n, x:JF64)              == Qnew1(n, x)
        qelt(x, i)                  == Qelt(x, i)
        elt(x, i:Integer) : JF64    == Qelt(x, i)
        qsetelt!(x, i, s:JF64)      == Qsetelt(x, i, s)
        setelt!(x : %, i : Integer, s : JF64) == Qsetelt(x, i, s)
        fill!(v, x)       == (for i in 1..Qsize v repeat Qsetelt(v, i, x); v)
        less?(v,n) == #v < n
        vector l == construct l
        coerce(x) : DoubleFloatVector == copy(x) pretend DoubleFloatVector
        coerce!(x) : DoubleFloatVector == x pretend DoubleFloatVector
        coerce(x) : OutputForm      ==
            ~pprint =>
                bracket [qelt(x, k)::OutputForm for k in 1$Lisp .. maxIndex x]
            jlDisplay(x)
            message("Julia Output")

        copy!(b, a) ==
            jl_1d2function(0$NNI,"copy!",b,a)$Lisp
            b

        copy(a) ==
            b := qnew(Qsize a)
            jl_1d2function(0$NNI,"copy!",b,a)$Lisp
            b

        jlApply(func, v : %) : Void ==
            defined?(func)
            jl_1dfunction(0$NNI,func, v)$Lisp
        jlApply(func, v : %) : JF64 ==
            defined?(func)
            jl_dbl_1dfunction(0$NNI, func, v)$Lisp
        jlApply(func, v : %, val : JF64) : JF64 ==
            defined?(func)
            jl_dbl_1dfunction_dbl(0$NNI, func, v, val)$Lisp
        jlApply(func, v1, v2) : Void ==
            defined?(func)
            jl_1d2function(0$NNI, func, v1, v2)$Lisp
        jlApply(func, v1, v2, v3) : Void ==
            defined?(func)
            jl_1d3function(func, v1, v2, v3)$Lisp

        juliaVPrint(b) ==
            oldpprint := pprint
            pprint:=b
            oldpprint

        jlDisplay(v) == jl_1dfunction(0$NNI,"display", v)$Lisp

        length(v) == jl_dbl_1dfunction(0$NNI,"norm", v)$Lisp

        reverse(v) ==
            vt := copy(v)
            jl_1dfunction(0$NNI,"reverse!", vt)$Lisp
            vt

        reverse!(v) == (jl_1dfunction(0$NNI,"reverse!", v)$Lisp;v)

        sort(v) ==
            vt := copy(v)
            jl_1dfunction(0$NNI,"sort!", vt)$Lisp;
            vt

        sort!(v) == (jl_1dfunction(0$NNI,"sort!", v)$Lisp;v)

        dot(v1,v2) == jl_dbl_1d2function(0$NNI,"dot",v1,v2)$Lisp

        urand01(n) ==
            v := qnew(n)
            for i in 1..maxIndex(v) repeat setelt!(v, i, RANDOM(1$JF64)$Lisp)
            v

        urand(n, r) ==
            v := qnew(n)
            for i in 1..maxIndex(v) repeat setelt!(v, i, RANDOM(r)$Lisp)
            v

        nrand(n) ==
            v := qnew(n)
            jl_1dfunction(0$NNI,"randn!", v)$Lisp
            v

)abbrev domain JF64MAT JuliaFloat64Matrix
++ Description: This domain provides a fast JuliaFloat64 matrix type
++ with no bound checking on elt's. Minimum index is 1.
JuliaFloat64Matrix() :  Exports == Implementation where
    NNI         ==> NonNegativeInteger
    INT         ==> Integer
    JF64        ==> JuliaFloat64
    JF64VEC     ==> JuliaFloat64Vector
    Qnew        ==> make_df_array2$Lisp
    Qnew1       ==> make_df_iarray2$Lisp
    Qelt2       ==> DFAREF21$Lisp
    Qsetelt2    ==> DFSETAREF21$Lisp
    Exports ==> JuliaMatrixCategory(JuliaFloat64,
                                   JuliaFloat64Vector,
                                   JuliaFloat64Vector) with
        coerce: % -> Matrix(DoubleFloat)
        ++ coerce(m) coerces a copy of m to a Matrix(DoubleFloat).
        jlVector: % -> JuliaFloat64Vector
        ++ jlVector(m) returns reference to the internal vector representation.
        jlApply : (JuliaString, %) -> Void
        ++ jlApply(func, x) apply func to argument x.
        jlApply : (JuliaString, %) -> JF64
        ++ jlApply(func, x) apply func to argument x.
        jlApply : (JuliaString, %, JF64) -> JF64
        ++ jlApply(func, x, val) apply func to arguments x and val.
        jlDisplay: % -> Void
        ++ jldisplay(m) pretty prints m (à la Julia).
        juliaMPrint : Boolean -> Boolean
        ++ juliaMPrint(b) defines whether or not FriCAS uses 
        ++ the printing version of Julia for matrices instead of
        ++ its OutputForm version. Returns previous value.
        ++ By default it is the Julia version.
        copy!: (%, %) -> %
        ++ copy!(b,a) copies efficiently a to b.No check are done on
        ++ arrays dimensions.
        identity:    NNI -> %
        ++ identity(n) returns a n by n identity matrix.S
        urand   :   (NNI, NNI, JF64) -> %
        ++ urand(m,n,x) returns a uniform(0$NNI..x) Julia matrix of size (m,n).
        urand01 :   (NNI, NNI) -> %
        ++ urand01(m,n) returns a uniform(0$NNI..1) Julia matrix of size (m,n).
        nrand :   (NNI, NNI) -> %
        ++ nrand(m,n) returns a normally distributed Julia matrix of size (m,n)
        ++ with mean=0 and standard deviation=1.
        positiveDefinite? : % -> Boolean
        ++ positiveDefinite?(m) tests wether or not m is positive definite.
        ++ Use a Cholesky factorisation.
        symmetricPart: % -> %
        ++ symmetricPart(m) returns the symmetric part of m (m + m')/2.
        symmetricPart!: % -> %
        ++ symmetricPart!(m) overwites m with the symmetric part of m (m + m')/2
        ++ to save memory space and returns m.
        skewPart: % -> %
        ++ skewPart(m) returns the skew part of m (m - m')/2.
        diagonalMatrix:   JF64VEC -> %
        ++ diagonalMatrix(v) returns a diagonal matrix with elements of v.
        transpose!:     (%, %) -> %
        ++ transpose!(b, a) stores transposed a in b.
    Implementation ==> add
        import from JuliaUtilityFunctions
        import from JuliaRealLinearAlgebra
        import from JuliaFloat64Vector

        Rep := Record(elts : JuliaFloat64Vector,
            ncols : NonNegativeInteger, nrows : NonNegativeInteger)

        defined?(func) ==>
            not jlDefined?(func) =>
                error concat(string(func), " is not defined in Julia")
        pprint := true

        minRowIndex x == 1
        minColIndex x == 1
        nrows x == x.ncols
        ncols x == x.nrows
        maxRowIndex x == x.ncols
        maxColIndex x == x.nrows
        #m == #m.elts

        qelt(m, i, j) == Qelt2(m.elts, m.ncols, m.nrows, j, i)
        elt(m:%, i:INT, j:INT) : JF64 == Qelt2(m.elts, m.ncols, m.nrows, j, i)
        qsetelt!(m, i, j, r) == Qsetelt2(m.elts, m.ncols, m.nrows, j, i, r)
        setelt!(m : %, i : Integer, j : Integer, r : JF64) ==
            Qsetelt2(m.elts, m.ncols, m.nrows, j, i, r)
        empty() == Qnew(0$Integer,0$Integer)
        qnew(rows, cols) ==
            m: JuliaFloat64Vector := Qnew(rows, cols)
            [m, rows, cols]
    
        new(rows, cols, a) ==
            m: JuliaFloat64Vector := Qnew1(cols, rows, a)
            [m, rows, cols]
        jlVector(mat) == mat.elts
    
        zero(m,n) == new(m,n,0)

        jlApply(func, m : %) : Void ==
            defined?(func)
            jl_2dfunction(0$NNI,func, m.elts, m.ncols)$Lisp
        jlApply(func, m : %) : JF64 ==
            defined?(func)
            jl_dbl_2dfunction(0$NNI, func, m.elts, m.ncols)$Lisp
        jlApply(func, m : %, val : JF64) : JF64 ==
            defined?(func)
            jl_dbl_2dfunction_dbl(0$NNI,func,  m.elts, m.ncols, val)$Lisp

        jlDisplay(m) ==
            jl_2dfunction(0$NNI,"display", m.elts, m.ncols)$Lisp

        juliaMPrint(b) ==
            oldpprint := pprint
            pprint:=b
            oldpprint

        coerce(m : %) : OutputForm ==
            if pprint then
                jlDisplay(m)
                message("Julia Output")
            else
                l : List List OutputForm
                l := [[qelt(m, j, i) :: OutputForm _
                    for i in 1 .. ncols(m)] _
                    for j in 1 .. nrows(m)]
                matrix l

        coerce(m : %) : Matrix(DoubleFloat) ==
            l : List List DoubleFloat
            l := [[qelt(m, j, i)::DoubleFloat _
                for i in 1 .. ncols(m)] _
                for j in 1 .. nrows(m)]
            matrix l

        square?(m) == m.nrows = m.ncols
        zero?(m) == jl_bool_2dfunction(0$NNI, "iszero", m.elts, m.ncols)$Lisp
        diagonal?(m) == jl_bool_2dfunction(0$NNI, "isdiag", m.elts, m.ncols)$Lisp
        symmetric?(m : %) : Boolean ==
           jl_bool_2dfunction(0$NNI,"issymmetric", m.elts, m.ncols)$Lisp
        positiveDefinite?(m : %) : Boolean ==
           jl_bool_2dfunction(0$NNI,"isposdef", m.elts, m.ncols)$Lisp

        copy!(b, a) ==
            jl_2d2function(0$NNI,"copy!",
                b.elts, b.ncols, a.elts, a.ncols)$Lisp
            b

        copy(a) ==
            b := qnew(a.nrows, a.ncols)
            jl_2d2function(0$NNI,"copy!",
                b.elts, b.ncols, a.elts, a.ncols)$Lisp
            b

        transpose(m) ==
            b := qnew(m.ncols, m.nrows)
            jl_2d2function(0$NNI,"transpose!",
                b.elts, b.ncols, m.elts, m.ncols)$Lisp
            b

        transpose!(b,a) ==
            jl_2d2function(0$NNI,"transpose!",
                b.elts, b.ncols, a.elts, a.ncols)$Lisp
            b

        -- ??? why the pretend?
        rank(m) ==
            prec : JF64 := DOUBLE_-FLOAT_-EPSILON$Lisp
            rank(m pretend JuliaFloat64Matrix,
                prec * jf64(10))$JuliaRealLinearAlgebra

        inverse(m) ==
            m.nrows ~= m.ncols => error "inverse: matrix is not square"
            inv := qnew(m.ncols, m.ncols)
            jl_array_2dfunction(0$NNI,0$NNI,"inv", inv.elts, m.elts, m.ncols)$Lisp
            inv

        symmetricPart(m) ==
            m.nrows ~= m.ncols => error "symmetricPart: matrix is not square"
            sym := copy m
            jl_2dfunction(0$NNI,"hermitianpart!", sym.elts, sym.ncols)$Lisp
            sym

        symmetricPart!(m) ==
            m.nrows ~= m.ncols => error "symmetricPart!: matrix is not square"
            jl_2dfunction(0$NNI,"hermitianpart!", m.elts, m.ncols)$Lisp
            m

        skewPart(m) ==
            m.nrows ~= m.ncols => error "skewPart: matrix is not square"
            sym := copy m
            jl_2dfunction(0$NNI,"hermitianpart!", sym.elts, sym.ncols)$Lisp
            m - sym

        a : % * b : % ==
            (nr := a.nrows) ~= (nc := b.ncols) =>
                error "Matrix multiplication: ncols(a) ~= nrows(b)"
            c := qnew(nrows(a), ncols(b))
            jl_2d3function(0$NNI,"mul!", c.elts, c.ncols,
                a.elts, a.ncols, b.elts, b.ncols)$Lisp
            c

        identity(n) ==
            m := new(n,n,0)
            for i in 1..n repeat setelt!(m,i,i,1)
            m

        urand01(m, n) ==
            mat := qnew(m,n)
            for i in 1 .. ncols(mat) repeat _
            for j in 1 .. nrows(mat) repeat _
                setelt!(mat, j, i, RANDOM(1$JF64)$Lisp)
            mat

        urand(m, n, r) ==
            mat := qnew(m,n)
            for i in 1 .. ncols(mat) repeat _
            for j in 1 .. nrows(mat) repeat _
                setelt!(mat, j, i, RANDOM(r)$Lisp)
            mat

        nrand(m, n) ==
            mat := qnew(m,n)
            jl_2dfunction(0$NNI,"randn!", mat.elts, mat.ncols)$Lisp
            mat

        determinant(m) ==
            m.nrows ~= m.ncols => error "determinant: matrix is not square"
            jl_dbl_2dfunction(0$NNI,"det", m.elts, m.ncols)$Lisp
        
        diagonalMatrix(v:JF64VEC) ==
            n : NNI := #v
            u := new(n, n, 0$JF64)
            for i in 1..n repeat setelt!(u, i, i, elt(v,i))
            u


)abbrev domain JF64SMAT JuliaF64SquareMatrix
++ Description: This domain provides a fast Julia Float64
++ square matrix type with no bound checking on elt's. Minimum index is 1.
JuliaF64SquareMatrix(n: NonNegativeInteger) : Join(JuliaType,
            SquareMatrixCategory(n, JuliaFloat64, 
                JuliaFloat64Vector, JuliaFloat64Vector),
                CoercibleTo(JuliaFloat64Matrix)) with
        qcoerce: JuliaFloat64Matrix -> %
        ++ qcoerce(m) coerces m to JuliaF64SquareMatrix
        ++ trusting that m is square.
        squareMatrix: JuliaFloat64Matrix -> %
        ++ squareMatrix(m) returns a copy of m as a JuliaF64SquareMatrix.
    == SubDomain(JuliaFloat64Matrix, square?(#1)) add
        import from JuliaFloat64Matrix
        JF64MAT ==> JuliaFloat64Matrix
        NNI ==> NonNegativeInteger
        qcoerce(m) == m pretend %
        coerce(m) == m pretend JuliaFloat64Matrix

        0  : % == new(n,n,0)$JF64MAT pretend %
        1  : % == scalarMatrix(n,1)$JF64MAT pretend %
        scalarMatrix(x) == scalarMatrix(n, x)$JF64MAT pretend %

        matrix(ll) ==
            (#ll = n) and (#ll.1 = n) => matrix(ll)$JF64MAT pretend %
            error "matrix: incompatible dimensions"

        squareMatrix(m) ==
            nr := nrows(m)
            nr ~= n or nr ~= ncols(m) => error
                "squareMatrix: incompatible dimensions"
            copy(m) pretend %

        one?(m) == jl_bool_2dfunction(0$NNI, "isone",
                    jlVector(m pretend JF64MAT), ncols(m pretend JF64MAT))$Lisp

)abbrev domain JCF64VEC JuliaComplexF64Vector
++ Description: This domain provides a fast JuliaComplexF64 vector type
++ with no bound checking on elt's. Minimum index is 1.
JuliaComplexF64Vector() :  Exports == Implementation where
    NNI         ==> NonNegativeInteger
    JF64        ==> JuliaFloat64
    JF64VEC     ==> JuliaFloat64Vector
    Qelt1       ==> JCDELT$Lisp
    Qsetelt1    ==> JCDSETELT$Lisp
    Qsize       ==> CDLEN$Lisp
    Qnew        ==> MAKE_CDOUBLE_VECTOR$Lisp
    Exports ==> JuliaVectorCategory(JuliaComplexF64) with
        qnew : NNI -> %
          ++ qnew(n) creates a new uninitialized vector of length n.
        vector : List JuliaComplexF64 -> %
        ++ vector(l) converts the list l to a vector.
        real : % -> JF64VEC
        ++ real(v) returns a Julia Float64 vector with the v elements real part.
        imag : % -> JF64VEC
        ++ imag(v) returns a Julia Float64 vector with the v elements imaginary part.
        copy!   : (%, %) -> %
        ++ copy!(b,a) copies efficiently a to b. No check are done on
        ++ arrays dimension.
        jlApply : (JuliaString, %) -> Void
        ++ jlApply(func, x) apply func to argument x.
        jlApply : (JuliaString, %) -> JF64
        ++ jlApply(func, x) apply func to argument x.
        jlApply : (JuliaString, %, JF64) -> JF64
        ++ jlApply(func, x, val) apply func to arguments x and val.
        urand01 :   NNI -> %
        ++ urand01(n) returns a uniform(0$NNI..1) Julia vector of size n.
        nrand :   NNI -> %
        ++ nrand(n) returns a normally distributed Julia vector of size n.
        ++ See Julia documentation (randn) for this complex version used here.
        jlDisplay : % -> Void
        ++ jldisplay(v) pretty prints v (à la Julia).
        juliaCVPrint : Boolean -> Boolean
        ++ juliaCVPrint(b) defines whether or not FriCAS uses 
        ++ the printing version of Julia for matrices instead of
        ++ its OutputForm version. Returns previous value.
        ++ By default it is the Julia version.
    Implementation ==> add
        import from JuliaUtilityFunctions
        import from JuliaComplexLinearAlgebra
        defined?(func) ==>
            not jlDefined?(func) =>
                error concat(string(func), " is not defined in Julia")
        pprint := true

        qelt(x, i)                  == Qelt1(x, i)
        elt(x, i)     == Qelt1(x, i)
        qsetelt!(x, i, s)           == Qsetelt1(x, i, s)
        setelt!(x : %, i : Integer, s:JuliaComplexF64) ==
            Qsetelt1(x, i, s)
        #x                          == Qsize x
        minIndex x                  == 1
        empty()                     == Qnew(0$Lisp)
        qnew(n)                     == Qnew(n)
        new(n, x)                   ==
            res : % := Qnew(n)
            fill!(res, x)
        vector l == construct l

        fill!(x, s)                 ==
            for i in 1..Qsize(x) repeat Qsetelt1(x, i, s)
            x

        real(v) ==
            ret := qnew(#v)$JF64VEC
            jl_array_1dfunction(1$NNI,"real", ret, v)$Lisp
            ret

        imag(v) ==
            ret := qnew(#v)$JF64VEC
            jl_array_1dfunction(1$NNI,"imag", ret, v)$Lisp
            ret
        
        copy!(b, a) ==
            jl_1d2function(1$NNI,"copy!",b,a)$Lisp
            b

        copy(a) ==
            b := qnew(Qsize a)
            jl_1d2function(1$NNI,"copy!",b,a)$Lisp
            b

        jlApply(func, v : %) : Void ==
            defined?(func)
            jl_1dfunction(1$NNI, func, v)$Lisp
        jlApply(func, v : %) : JF64 ==
            defined?(func)
            jl_dbl_1dfunction(1$NNI, func, v)$Lisp
        jlApply(func, v : %, val : JF64) : JF64 ==
            defined?(func)
            jl_dbl_1dfunction_dbl(1$NNI,func, v, val)$Lisp

        urand01(n) ==
            v := qnew(n)
            for i in 1..maxIndex(v) repeat
                setelt!(v, i, complex(RANDOM(1$JF64)$Lisp,RANDOM(1$JF64)$Lisp))
            v

        nrand(n) ==
            v := qnew(n)
            jl_1dfunction(1$NNI, "randn!", v)$Lisp
            v

        juliaCVPrint(b) ==
            oldpprint := pprint
            pprint:=b
            oldpprint

        jlDisplay(v) == jl_1dfunction(1$NNI,"display", v)$Lisp

        coerce(v) : OutputForm      ==
            ~pprint =>
                bracket [qelt(v, k)::OutputForm for k in 1$Lisp .. maxIndex v]
            jlDisplay(v)
            message("Julia Output")


)abbrev domain JCF64MAT JuliaComplexF64Matrix
++ Description: This domain provides a fast JuliaComplexF64 matrix type
++ with no bound checking on elt's. Minimum index is 1.
JuliaComplexF64Matrix() : Exports == Implementation where
    JF64        ==> JuliaFloat64
    JF64MAT     ==> JuliaFloat64Matrix
    JCF64       ==> JuliaComplexF64
    JCF64VEC    ==> JuliaComplexF64Vector
    NNI         ==> NonNegativeInteger
    Qelt2       ==> JCDELT2$Lisp
    Qsetelt2    ==> JCDSETELT2$Lisp
    Qnew        ==> MAKE_CDOUBLE_VECTOR$Lisp
    Exports ==> JuliaMatrixCategory(JuliaComplexF64,
                    JuliaComplexF64Vector,
                    JuliaComplexF64Vector) with
        coerce: JF64MAT -> %
        ++ coerce(m) coerces m to a a Julia Complex Float 64 matrix.
        jlDisplay : % -> Void  
        ++ jlDisplay(m) pretty prints m (à la Julia).
        jlVector: % -> JuliaComplexF64Vector
        ++ jlVector(m) returns reference to the internal vector representation.
        real : % -> JF64MAT
        ++ real(m) returns a Julia Float64 matrix with the m elements real part.
        imag : % -> JF64MAT
        ++ imag(m) returns a Julia Float64 matrix with the m elements imaginary part.
        jlApply : (JuliaString, %) -> Void
        ++ jlApply(func, x) apply func to argument x.
        jlApply : (JuliaString, %) -> JF64
        ++ jlApply(func, x) apply func to argument x.
        jlApply : (JuliaString, %, JF64) -> JF64
        ++ jlApply(func, x, val) apply func to arguments x and val.
        hermitian? : % -> Boolean
        ++ hermitian?(m) tests hermiticity of m.
        positiveDefinite? : % -> Boolean
        ++ positiveDefinite?(m) tests wether or not m is Hermitian
        ++ positive definite using a Cholesky factorisation.
        hermitianPart: % -> %
        ++ hermitianPart(m) returns the symmetric part of m (m + m')/2.
        hermitianPart!: % -> %
        ++ hermitianPart!(m) overwites m with the symmetric part of m (m + m')/2
        ++ to save memory space and returns m.
        copy!   : (%, %) -> %
        ++ copy!(b,a) copies efficiently a to b. No check are done on
        ++ arrays dimensions.
        diagonalMatrix:   JCF64VEC -> %
        ++ diagonalMatrix(v) returns a diagonal matrix with elements of v.
        urand01:   (NNI, NNI) -> %
        ++ urand01(m,n) returns a uniform(0$NNI..1) Julia matrix of size (m,n).
        nrand :   (NNI, NNI) -> %
        ++ nrand(m,n) returns a normally distributed Julia matrix of size (m,n).
        ++ See Julia documentation (randn) for this complex version used here.
        transpose!:     (%, %) -> %
        ++ transpose!(b, a) stores transposed a in b.
        adjoint:     % -> %
        ++ adjoint(m) returns the adjoint of m i.e. the conjugate
        ++ transposition of m.
        adjoint!:     (%, %) -> %
        ++ adjoint!(a, m) stores in a the adjoint of m i.e.
        ++ the conjugate transposition of m.
        juliaCMPrint : Boolean -> Boolean
        ++ juliaMPrint(b) defines whether or not FriCAS uses 
        ++ the printing version of Julia for matrices instead of
        ++ its OutputForm version. Returns previous value.
        ++ By default it is the Julia version.
    Implementation ==> add
        import from JuliaUtilityFunctions
        import from JuliaComplexLinearAlgebra
        import from JuliaFloat64Vector
        import from JuliaFloat64Matrix

        defined?(func) ==>
            not jlDefined?(func) =>
                error concat(string(func), " is not defined in Julia")
        pprint := true

        Rep := Record(elts : JuliaComplexF64Vector,
            ncols : NonNegativeInteger, nrows : NonNegativeInteger)

        minRowIndex x == 1
        minColIndex x == 1
        nrows x == x.ncols
        ncols x == x.nrows
        maxRowIndex x == x.ncols
        maxColIndex x == x.nrows

        qelt(m, i, j) == Qelt2(m.elts, m.ncols, j, i)
        elt(m : %, i : Integer, j : Integer) : JCF64 ==
            Qelt2(m.elts, m.ncols, j, i)
        qsetelt!(m, i, j, r) == Qsetelt2(m.elts, m.ncols, j, i, r)
        setelt!(m : %, i : Integer, j : Integer, r : JCF64) ==
            Qsetelt2(m.elts, m.ncols, j, i, r)

        empty() == [empty()$JCF64VEC, 0, 0]
        qnew(rows, cols) ==
            vec : JCF64VEC := Qnew(rows*cols)
            [vec, rows, cols]
        new(rows, cols, a) ==
            vec : JCF64VEC := new(rows*cols, a)
            [vec,rows,cols]
        jlVector(mat) == mat.elts

        zero(m,n) == new(m,n,0)

        real(m) ==
            nr := nrows(m)
            ret := qnew(nr, ncols(m))$JF64MAT
            jl_array_2dfunction(0$NNI,1$NNI,"real",
                jlVector(ret), jlVector(m), nr)$Lisp
            ret

        imag(m) ==
            nr := nrows(m)
            ret := qnew(nr, ncols(m))$JF64MAT
            jl_array_2dfunction(0$NNI,1$NNI,"imag",
                jlVector(ret), jlVector(m), nr)$Lisp
            ret

        square?(m) == m.nrows = m.ncols
        zero?(m) == jl_bool_2dfunction(1$NNI, "iszero", m.elts, m.ncols)$Lisp
        diagonal?(m) == jl_bool_2dfunction(1$NNI, "isdiag", m.elts, m.ncols)$Lisp
        symmetric?(m : %) : Boolean ==
            jl_bool_2dfunction(1$NNI,"issymmetric", m.elts, m.ncols)$Lisp
        hermitian?(m : %) : Boolean ==
            jl_bool_2dfunction(1$NNI,"ishermitian", m.elts, m.ncols)$Lisp
        positiveDefinite?(m : %) : Boolean ==
            jl_bool_2dfunction(1$NNI,"isposdef", m.elts, m.ncols)$Lisp

        hermitianPart(m) ==
            m.nrows ~= m.ncols => error "hermitianPart: matrix is not square"
            her := copy m
            jl_2dfunction(1$NNI,"hermitianpart!", her.elts, her.ncols)$Lisp
            her
        hermitianPart!(m) ==
            m.nrows ~= m.ncols => error "hermitianPart!: matrix is not square"
            jl_2dfunction(1$NNI,"hermitianpart!", m.elts, m.ncols)$Lisp
            m

        copy!(b, a) ==
            jl_2d2function(1$NNI,"copy!", b.elts, b.ncols,
                a.elts, a.ncols)$Lisp
            b

        copy(a) ==
            b := qnew(a.nrows, a.ncols)
            jl_2d2function(1$NNI,"copy!",
                b.elts, b.ncols, a.elts, a.ncols)$Lisp
            b

        transpose(m) ==
            b := qnew(m.ncols, m.nrows)
            jl_2d2function(1$NNI,"transpose!",
                b.elts, b.ncols, m.elts, m.ncols)$Lisp
            b

        transpose!(b,a) ==
            jl_2d2function(1$NNI,"transpose!",
                b.elts, b.ncols, a.elts, a.ncols)$Lisp
            b

        adjoint(m) ==
            b := qnew(m.ncols, m.nrows)
            jl_2d2function(1$NNI,"adjoint!",
                b.elts, b.ncols, m.elts, m.ncols)$Lisp
            b

        adjoint!(b,a) ==
            jl_2d2function(1$NNI,"adjoint!",
                b.elts, b.ncols, a.elts, a.ncols)$Lisp
            b

        jlApply(func, m : %) : Void ==
            defined?(func)
            jl_2dfunction(1$NNI,func, m.elts, m.ncols)$Lisp
        jlApply(func, m : %) : JF64 ==
            defined?(func)
            jl_dbl_2dfunction(1$NNI,func,  m.elts, m.ncols)$Lisp
        jlApply(func, m : %, val : JF64) : JF64 ==
            defined?(func)
            jl_dbl_2dfunction_dbl(1$NNI,func,  m.elts, m.ncols, val)$Lisp

        a : % * b : % ==
            (nr := a.nrows) ~= (nc := b.ncols) =>
                error "Matrix multiplication: ncols(a) ~= nrows(b)"
            c := qnew(nrows(a), ncols(b))
            jl_2d3function(1$NNI,"mul!", c.elts, c.ncols,
                a.elts, a.ncols, b.elts, b.ncols)$Lisp
            c

        -- ??? why the pretend?
        rank(m) ==
            prec : JF64 := DOUBLE_-FLOAT_-EPSILON$Lisp
            rank(m pretend JuliaComplexF64Matrix,
                prec * jf64(10))$JuliaComplexLinearAlgebra

        inverse(m) ==
            m.nrows ~= m.ncols => error "inverse: matrix is not square"
            inv : % := qnew(m.ncols, m.ncols)
            jl_array_2dfunction(1$NNI,1$NNI,"inv", inv.elts,
                m.elts, m.ncols)$Lisp
            inv

        -- Horrible temporary hack
        determinant(m) ==
            m.nrows ~= m.ncols => error "determinant: matrix is not square"
            determinant(matrix(listOfLists(m))@Matrix(JCF64))

        jlDisplay(m) ==
            jl_2dfunction(1$NNI,"display", m.elts, m.ncols)$Lisp

        juliaCMPrint(b) ==
            oldpprint := pprint
            pprint:=b
            oldpprint

        diagonalMatrix(v:JCF64VEC) ==
            n : NNI := #v
            u := new(n, n, 0$JCF64)
            for i in 1..n repeat setelt!(u, i, i, elt(v,i))
            u

        urand01(m, n) ==
            mat := qnew(m, n)
            for i in 1 .. ncols(mat) repeat _
            for j in 1 .. nrows(mat) repeat _
                setelt!(mat, j, i,
                    complex(RANDOM(1$JF64)$Lisp,RANDOM(1$JF64)$Lisp))
            mat

        nrand(m, n) ==
            mat := qnew(m, n)
            jl_2dfunction(1$NNI,"randn!", mat.elts, mat.ncols)$Lisp
            mat

        coerce(m : %) : OutputForm ==
            if pprint then
                jlDisplay(m)
                message("Julia Output")
            else
                l : List List OutputForm
                l := [[qelt(m, j, i) :: OutputForm _
                    for i in 1 .. maxColIndex(m)] _
                    for j in 1 .. maxRowIndex(m)]
                matrix l

        coerce(m : JuliaFloat64Matrix) : % ==
            newm := qnew(nrows(m), ncols(m))
            for i in 1 .. ncols(m) repeat
                for j in 1 .. nrows(m) repeat
                    qsetelt!(newm, i, j, complex(qelt(m, i, j), 0)$JCF64)             
            newm

)abbrev domain JCF64SMA JuliaComplexF64SquareMatrix
++ Description: This domain provides a fast Julia Float64
++ square matrix type with no bound checking on elt's. Minimum index is 1.
JuliaComplexF64SquareMatrix(n : NonNegativeInteger) : Join(JuliaType,
            SquareMatrixCategory(n, JuliaComplexF64, 
                JuliaComplexF64Vector, JuliaComplexF64Vector),
                CoercibleTo(JuliaComplexF64Matrix)) with
        qcoerce: JuliaComplexF64Matrix -> %
        ++ qcoerce(m) coerces m to JuliaComplexF64SquareMatrix
        ++ trusting that m is square.
        coerce: % -> JuliaComplexF64Matrix
        ++ coerce(m) coerces m to JuliaComplexF64Matrix
        squareMatrix: JuliaComplexF64Matrix -> %
        ++ squareMatrix(m) returns a copy of m as 
        ++ a JuliaComplexF64SquareMatrix.
    == SubDomain(JuliaComplexF64Matrix, square?(#1)) add
        import from JuliaComplexF64Matrix
        JCF64MAT ==> JuliaComplexF64Matrix
        NNI ==> NonNegativeInteger
        qcoerce(m) == m pretend %
        coerce(m) == m pretend JuliaComplexF64Matrix

        0  : % == new(n,n,0)$JCF64MAT pretend %
        1  : % == scalarMatrix(n,1)$JCF64MAT pretend %

        matrix(ll) ==
            (#ll = n) and (#ll.1 = n) => matrix(ll)$JCF64MAT pretend %
            error "matrix: incompatible dimensions"

        squareMatrix(m) ==
            nr := nrows(m)
            nr ~= n or nr ~= ncols(m) => error "squareMatrix: incompatible dimensions"
            copy(m) pretend %

        one?(m) == jl_bool_2dfunction(1$NNI, "isone",
                    jlVector(m pretend JCF64MAT), ncols(m pretend JCF64MAT))$Lisp
