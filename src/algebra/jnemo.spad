)abbrev domain JINT JuliaInteger
++ Experimental domain for Julia Integers
++ Author: G. Vanuxem
++ Date Created: Jan. 2023
++ Description:
++  This domain allows the manipulation of Julia Integers
++  using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaInteger() : Exports == Implementation where
  JI64      ==> JuliaInt64
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, OrderedSet, EuclideanDomain) with
    jlType  : % -> SExpression
    jlRef   : % -> SExpression
    jlValue : % -> SExpression
    jlId    : % -> SExpression
    "*"     : (%, Integer) -> %
    coerce  : JI64 -> %
    coerce  : % -> JI64
    coerce  : % -> Integer
    coerce  : % -> Expression Integer
    coerce  : % -> AlgebraicNumber
    jint    : Integer -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp
 
    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    ibinfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jlref(concat(["ZZ(", jl_string_eval_string(tmp)$Lisp,")"]), "ZZ")
    ibinbfunc(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp
    iunfunc(op, a) ==>
      tmp : String := concat(["string(", op, "(", getind(a),"))"])
      jlref(concat(["ZZ(",jl_string_eval_string(tmp)$Lisp, ")"]),"ZZ")
  
    0 == jlref("ZZ(0)", "ZZ")
    1 == jlref("ZZ(1)", "ZZ")

    x = y  == ibinbfunc("==",x,y)
    x ~= y == ibinbfunc("!=",x,y)
    x < y  == ibinbfunc("<",x,y)
    x > y  == ibinbfunc(">",x,y)
    x >= y == ibinbfunc(">=",x,y)
    x <= y == ibinbfunc("<=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == ibinfunc("+", x, y)
    x - y == ibinfunc("-", x, y)
    - x   == iunfunc("-", x)
    x : % * y : % == ibinfunc("*", x, y)
    x : Integer * y : % == coerce(x) * y
    x  * y : Integer == x * coerce(y)

    x : Integer * y : % ==
      i : % := coerce(x)
      tmp : String := concat(["string(", getind(i), "*", getind(y),")"])
      jlref(concat(["ZZ(", jl_string_eval_string(tmp)$Lisp,")"]), "ZZ")

    x ^ y : NonNegativeInteger ==
      ibinfunc("^", x, coerce(y pretend Integer))
    x ^ y : PositiveInteger ==
      ibinfunc("^", x, coerce(y pretend Integer))

    -- x quo y == ibinfunc("div", x, y)
    x quo y == ibinfunc("รท", x, y)
    x rem y == ibinfunc("%", x, y)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(jsi : %): JI64 ==
        x := parsei(jlrefVal(jsi))
        coerce(x)
    coerce(i : Integer) ==
      jlref(concat(["ZZ(",string(i),")"]), "ZZ")
    coerce(i : %) : OutputForm == jlrefVal(i)
    coerce(x : %) : Integer  == integer(jlrefVal x)
    coerce(x : %) : Expression(Integer)  ==
      coerce(parsei(jlrefVal x))$Expression(Integer)
    coerce(x : %) : AlgebraicNumber  ==
      coerce(parsei(jlrefVal x))$AlgebraicNumber
    jint(i : Integer) : % == jlref(concat(["ZZ(", string(i),")"]), "ZZ")

)abbrev domain JFINT JuliaFractionInteger
++ Experimental domain for Julia Fraction Integers
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Fraction Integers
++  using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaFractionInteger() : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  JINT      ==> JuliaInteger
  Exports ==> Join(JuliaType, QuotientFieldCategory(JuliaInteger)) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"     : (%, Integer) -> %
    coerce  : Fraction(Integer) -> %
    coerce  : JuliaInteger -> %
    jfint   : Integer -> %
    jfint   : Fraction(Integer) -> %
  Implementation ==> LocalAlgebra(JuliaInteger,JuliaInteger) add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    fibinfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jlref(concat(["QQ(", jl_string_eval_string(tmp)$Lisp,")"]), "QQ")

    fibinbfunc(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

    fiunfunc(op, a) ==>
      tmp : String := concat(["string(", op, "(", getind(a),"))"])
      jlref(concat(["QQ(",jl_string_eval_string(tmp)$Lisp, ")"]),"QQ")

    0 == jlref("QQ(0)", "QQ")
    1 == jlref("QQ(1)", "QQ")

    x = y  == fibinbfunc("==",x,y)
    x ~= y == fibinbfunc("!=",x,y)
    x < y  == fibinbfunc("<",x,y)
    x > y  == fibinbfunc(">",x,y)
    x >= y == fibinbfunc(">=",x,y)
    x <= y == fibinbfunc("<=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == fibinfunc("+", x, y)
    x - y == fibinfunc("-", x, y)
    - x   == fiunfunc("-", x)
    x : % * y : % == fibinfunc("*", x, y)
    x : % / y : % == fibinfunc("/", x, y)
    x : % * y : JuliaInteger == fibinfunc("*", x, y)
    x : JuliaInteger * y : % == fibinfunc("*", x, y)
    x : % * y : Integer == fibinfunc("*", x, coerce(y))
    x : Integer * y : % == fibinfunc("*", coerce(x), y)

    x ^ y : NonNegativeInteger == fibinfunc("^", x, coerce(y pretend Integer)@JINT)
    x ^ y : PositiveInteger == fibinfunc("^", x, coerce(y pretend Integer)@JINT)

    x quo y == fibinfunc("รท", x, y)
    -- x quo y == ibinfunc("div", x, y)
    x rem y == fibinfunc("%", x, y)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)  == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["QQ(", jl_string_eval_string(tmp)$Lisp, ")"]),"QQ")

    coerce(i : Integer) ==
      jlref(concat(["QQ(", string i,")"]), "QQ")

    coerce(x : Fraction(Integer)) ==
      jlref(concat(["QQ(", string(numer x),
        "//", string(denom x),")"]), "QQ")

    coerce(i : %) : OutputForm == jlrefVal(i)
    jfint(i : Integer) == coerce(i)
    jfint(fi : Fraction Integer) == coerce(fi)


)abbrev domain JZMOD JuliaIntegerMod
++ Experimental domain for Galois Fields
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Galois field
++  elements using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaIntegerMod(p : PositiveInteger) : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, CommutativeRing, Finite,
        ConvertibleTo Integer, StepThrough) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"      : (%, Integer) -> %
    "*"      : (Integer, %) -> %
    "*"      : (%, JuliaInteger) -> %
    "*"      : (JuliaInteger, %) -> %
    sqrt     : % -> %
    ++ sqrt(x) returns a square root of x.
    ++ Throw a Julia error if there is no square root and returns 0.
    "*"     : (%, Integer) -> %
    coerce  : Integer -> %
    coerce  : JuliaInteger -> %
    jzmod   : Integer -> %
    jzmod   : JuliaInteger -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    import from JuliaInteger
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["JZMOD",string(p),",=residue_ring(ZZ,", string(p),")"]))$Lisp

    -- jlref type
    JZMOD ==> concat(["JZMOD(ZZ,",string(p),")"])

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    jzmodbinfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jlref(concat(["JZMOD",string(p),"(", jl_string_eval_string(tmp)$Lisp,")"]), JZMOD)

    jzmodbinbfunc(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

    jzmodunfunc(op, a) ==>
      tmp : String := concat(["string(", op,"(" ,getind(a),"))"])
      jlref(concat(["JZMOD",string(p),"(", jl_string_eval_string(tmp)$Lisp, ")"]), JZMOD)

    0 == jlref(concat(["JZMOD",string(p),"(0)"]), JZMOD)
    1 == jlref(concat(["JZMOD",string(p),"(1)"]), JZMOD)
    init == 0
    nextItem(n) ==
        m := n+1$%
        m = 0 => "failed"
        m
    x = y == jzmodbinbfunc("==",x,y)
    x ~= y == jzmodbinbfunc("!=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == jzmodbinfunc("+", x, y)
    x - y == jzmodbinfunc("-", x, y)
    - x   == jzmodunfunc("-", x)
    x : % * y : % == jzmodbinfunc("*", x, y)
    x : % * y : JuliaInteger == jzmodbinfunc("*", x, y)
    x : JuliaInteger * y : % == jzmodbinfunc("*", x, y)
    x : % * y : Integer == jzmodbinfunc("*", x, coerce(y)@JuliaInteger)
    x : Integer * y : % == jzmodbinfunc("*", coerce(x)@JuliaInteger, y)

    x ^ y : NonNegativeInteger ==
      jzmodbinfunc("^", x, coerce(y pretend Integer)@JuliaInteger)
    x ^ y : PositiveInteger ==
      jzmodbinfunc("^", x, coerce(y pretend Integer)@JuliaInteger)
   
    if p <= convert(max()$SingleInteger)@Integer then
      q := p::SingleInteger
      recip x ==
        zero?(y := convert(x)@Integer :: SingleInteger) => "failed"
        invmod(y, q)::Integer::%
    else
      recip x ==
        zero?(y := convert(x)@Integer) => "failed"
        invmod(y, p)::%
    
    -- Internal error: Cannot determine branch of Union.
    -- recip(x) == jzmodunfunc("inv", x)

    size()           == p
    characteristic() == p
    lookup x == (zero? x => p; (convert(x)@Integer) :: PositiveInteger)
    convert(x : %) : Integer == parsei string jlrefVal(x)
    lookup x == (zero? x => p; (convert(x)@Integer) :: PositiveInteger)
    random() == coerce(random(p)$Integer)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["JZMOD",string(p),"(", jl_string_eval_string(tmp)$Lisp, ")"]),JZMOD)

    coerce(i : Integer) ==
      jlref(concat(["JZMOD",string(p),"(", string(i), ")"]), JZMOD)

    coerce(i : %) : OutputForm == jlrefVal(i)
    jzmod(i : Integer) == coerce(i)
    jzmod(ji : JuliaInteger) == coerce(ji)


)abbrev domain JGF JuliaGaloisField
++ Experimental domain for Galois Fields
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Galois field
++  elements using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaGaloisField(p : PositiveInteger) : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  SUP       ==> SparseUnivariatePolynomial
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, FiniteFieldCategory,
          FiniteAlgebraicExtensionField(%), ConvertibleTo(Integer)) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"      : (%, JuliaInteger) -> %
    "*"      : (JuliaInteger, %) -> %
    "*"      : (Integer, %) -> %
    "*"      : (%, Integer) -> %
    sqrt     : % -> %
    ++ sqrt(x) returns a square root of x.
    ++ Throw a Julia error if there is no square root and returns 0.
    coerce  : Integer -> %
    coerce  : JuliaInteger -> %
    jgf   : Integer -> %
    jgf   : JuliaInteger -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["GF",string(p),"=GF(", string(p),")"]))$Lisp

    -- jlref type
    GF ==> concat(["GF(",string(p),")"])

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    jgfbinfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jlref(concat(["GF",string(p),"(", jl_string_eval_string(tmp)$Lisp,")"]), GF)

    jgfbinbfunc(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

    jgfunfunc(op, a) ==>
      tmp : String := concat(["string(", op,"(" ,getind(a),"))"])
      jlref(concat(["GF",string(p),"(", jl_string_eval_string(tmp)$Lisp, ")"]), GF)

    0 == jlref(concat(["GF",string(p),"(0)"]), GF)
    1 == jlref(concat(["GF",string(p),"(1)"]), GF)

    x = y == jgfbinbfunc("==",x,y)
    x ~= y == jgfbinbfunc("!=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == jgfbinfunc("+", x, y)
    x - y == jgfbinfunc("-", x, y)
    - x   == jgfunfunc("-", x)
    x : % * y : % == jgfbinfunc("*", x, y)
    x : % * y : JuliaInteger == jgfbinfunc("*", x, y)
    x : JuliaInteger * y : % == jgfbinfunc("*", x, y)
    x : % * y : Integer == jgfbinfunc("*", x, coerce(y)@JuliaInteger)
    x : Integer * y : % == jgfbinfunc("*", coerce(x)@JuliaInteger, y)
    x : % / y : % == jgfbinfunc("/", x, y)


    x ^ y : NonNegativeInteger ==
      jgfbinfunc("^", x, coerce(y pretend Integer)@JuliaInteger)
    x ^ y : PositiveInteger ==
      jgfbinfunc("^", x, coerce(y pretend Integer)@JuliaInteger)

    x quo y == jgfbinfunc("รท", x, y)
    -- x quo y == ibinfunc("div", x, y)
    x rem y == jgfbinfunc("%", x, y)

    if p <= convert(max()$SingleInteger)@Integer then
      q := p::SingleInteger
      recip x ==
        zero?(y := convert(x)@Integer :: SingleInteger) => "failed"
        invmod(y, q)::Integer::%
    else
      recip x ==
        zero?(y := convert(x)@Integer) => "failed"
        invmod(y, p)::%
    
    -- Internal error: Cannot determine branch of Union.
    -- recip(x) == jgfunfunc("inv", x)

    generator() == 1
    normalElement() == 1
    createNormalElement() == 1
    characteristic() == p pretend NNI
    representationType() == "prime"
    degree(x) : PI == 1$PositiveInteger
    extensionDegree() : PI == 1$PositiveInteger
    charthRoot(x : %) : % == x
    inGroundField?(x)  == true
    coordinates(x : %) : Vector(%) == new(1, x)$(Vector %)
    represents(v)  == v(1)
    retract(x) == x
    retractIfCan(x) == x

    basis() == new(1, 1::%)$(Vector %)
    basis(n : PI) ==
      n = 1 => basis()
      error("basis: argument must divide extension degree")

    definingPolynomial() ==
      monomial(1, 1)$(SUP %) - monomial(1, 0)$(SUP %)

    minimalPolynomial(x) ==
      monomial(1, 1)$(SUP %) - monomial(x, 0)$(SUP %)

    sqrt(x) == jgfunfunc("sqrt", x)

    convert(x : %) : Integer == parsei string jlrefVal(x)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["GF",string(p),"(", jl_string_eval_string(tmp)$Lisp, ")"]),GF)

    coerce(i : Integer) ==
      jlref(concat(["GF",string(p),"(", string(i), ")"]), GF)

    coerce(i : %) : OutputForm == jlrefVal(i)
    jgf(i : Integer) == coerce(i)
    jgf(ji : JuliaInteger) == coerce(ji)


)abbrev domain JUP JuliaUnivariatePolynomial
++ Test package
JuliaUnivariatePolynomial(x : Symbol, R : Join(JuliaType, Ring)):
  Exports == Implementation where
    jlrefVal  ==> JLREFVAL$Lisp
    jlrefType ==> JLREFTYPE$Lisp
    jlrefId   ==> JLREFID$Lisp
    jlref     ==> make_jlref$Lisp 
    JINT      ==> JuliaInteger
    JI64      ==> JuliaInt64
    Exports ==> UnivariatePolynomialCategory(R) with
        jup     : UnivariatePolynomial(x,R) -> %
        ++ jup(p) converts the univariate polynomial p to
        ++ a Julia univariate polynomial.
        coerce  : Variable(x) -> %
        ++ coerce(x) converts the variable x to a Julia univariate polynomial.
        "*"       : (%, PositiveInteger) -> %
        "*"       : (%, NonNegativeInteger) -> %
    Implementation ==> add
        import from JuliaUtilityFunctions
        import from JuliaString
        import String
        --import from UnivariatePolynomial(x,R)
    
        jlInitialize(true)
        jl_eval_string("@suppress_err using Nemo")$Lisp
        -- jlref CL class
        Rep := SExpression


        spjs(str) ==> str pretend JuliaString

        getind(a) ==> concat(["getindex(", "refs,_"", jlrefId(a), "_")"])

        upbinfunc(op,a,b) ==>
          tmp : String := concat(["string(", getind(a), op, getind(b),")"])
          jlref(concat(["R(", jl_string_eval_string(tmp)$Lisp,")"]), "JUP")
        upbinbfunc(op,a,b) ==>
          tmp : String := concat([getind(a), op, getind(b)])
          jl_bool_eval_string(tmp)$Lisp
        upunfunc(op, a) ==>
          tmp : String := concat(["string(", op, getind(a),")"])
          jlref(concat(["R(",jl_string_eval_string(tmp)$Lisp, ")"]),"JUP")

        peval(expr) ==> concat(["eval(string(Meta.parse(_"",expr,"_")))"])

        if R is JuliaInteger then
            jl_eval_string(concat(["R,", string(x), "=polynomial_ring(ZZ,_"",
                string(x), "_")"])$String)$Lisp
            leadingCoefficient(p : %) ==
              tmp : String := concat(["leading_coefficient(", getind(p),")"])
              jlref(tmp, "ZZ")
        else if R is JuliaFractionInteger then
            jl_eval_string(concat(["R,", string(x), "=polynomial_ring(QQ,_"",
                string(x), "_")"])$String)$Lisp
            leadingCoefficient(p : %) ==
              tmp : String := concat(["leading_coefficient(", getind(p),")"])
              jlref(tmp, "QQ")
        else error "Unimplemented ring."

        1 == jlref("R(1)", "JUP")
        0 == jlref("R(0)", "JUP")
        - a == upunfunc("-",a)
        a : % = b : % == upbinbfunc("==",a,b)
        a : % ~= b : % == upbinbfunc("!=",a,b)
        a : % + b : % == upbinfunc("+",a,b)
        a : % - b : % == upbinfunc("-",a,b)
        a : % * b : % == upbinfunc("*",a,b)
        i : Integer  * b : % == upbinfunc("*", coerce(i)@%, b)
        a : % * i : Integer  == upbinfunc("*", a, coerce(i)@%)
        a : % * i : PositiveInteger  == upbinfunc("*", a, coerce(i pretend Integer)@%)
        a : % * i : NonNegativeInteger  == upbinfunc("*", a, coerce(i pretend Integer)@%)

        degree(p) ==
          tmp : String := concat(["degree(", getind(p),")"])
          jl_int64_eval_string(tmp)$Lisp   

        jup(up) : % ==
            p:= first(lines formatExpression(up::OutputForm)$Format1D)
            jlref(peval(p), "JUP")

        coerce(v : Variable(x)) == jlref(string(v::Symbol),"JUP")
        coerce(i : Integer) == jlref(concat(["R(",string(i),")"]),"JUP")
        coerce(p : %) : OutputForm == jlrefVal p
