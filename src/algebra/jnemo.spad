)abbrev domain JINT JuliaInteger
++ Experimental domain for Julia Integers
++ Author: G. Vanuxem
++ Date Created: Jan. 2023
++ Description:
++  This domain allows the manipulation of Julia Integers
++  using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaInteger() : Exports == Implementation where
  JI64      ==> JuliaInt64
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  -- PARSE-INTEGER$Lisp
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, OrderedSet, EuclideanDomain) with
    jlType  : % -> SExpression
    jlRef   : % -> SExpression
    jlValue : % -> SExpression
    jlId    : % -> SExpression
    coerce  : JI64 -> %
    coerce  : % -> JI64
    coerce  : % -> Integer
    coerce  : % -> Expression Integer
    coerce  : % -> AlgebraicNumber
    jint    : Integer -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    
    jlInitialize(true)
    jlUsing(jstring "Nemo")
 
    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    ibinfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jlref(concat(["ZZ(", jl_string_eval_string(tmp)$Lisp,")"]), "ZZ")
    ibinbfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jl_bool_eval_string(tmp)$Lisp
    iunfunc(op, a) ==>
      tmp : String := concat(["string(", op, getind(a),")"])
      jlref(concat(["ZZ(",jl_string_eval_string(tmp)$Lisp, ")"]),"ZZ")
  
    0 == jlref("ZZ(0)", "ZZ")
    1 == jlref("ZZ(1)", "ZZ")

    x = y  == ibinbfunc("==",x,y)
    x ~= y == ibinbfunc("!=",x,y)
    x < y  == ibinbfunc("<",x,y)
    x > y  == ibinbfunc(">",x,y)
    x >= y == ibinbfunc(">=",x,y)
    x <= y == ibinbfunc("<=",x,y)

    x + y == ibinfunc("+", x, y)
    x - y == ibinfunc("-", x, y)
    - x   == iunfunc("-", x)
    x : % * y : % == ibinfunc("*", x, y)

    x ^ y : NonNegativeInteger ==
      ibinfunc("^", x, jlref(concat(["ZZ(",string(coerce(y)),")"]), "ZZ"))
    x ^ y : PositiveInteger ==
      ibinfunc("^", x, jlref(concat(["ZZ(",string(coerce(y)),")"]), "ZZ"))

    -- x quo y == ibinfunc("div", x, y)
    x quo y == ibinfunc("รท", x, y)
    x rem y == ibinfunc("%", x, y)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(jsi : %): JI64 ==
        x := parsei(jlrefVal(jsi))
        coerce(x)
    coerce(i : Integer) ==
      jlref(concat(["ZZ(",string(i),")"]), "ZZ")
    coerce(i : %) : OutputForm == jlrefVal(i)
    coerce(x : %) : Integer  == integer(jlrefVal x)
    coerce(x : %) : Expression(Integer)  ==
      coerce(parsei(jlrefVal x))$Expression(Integer)
    coerce(x : %) : AlgebraicNumber  ==
      coerce(parsei(jlrefVal x))$AlgebraicNumber
    convert(x : %) : Integer  == parsei(jlrefVal(x))
    jint(i : Integer) : % == jlref(concat(["ZZ(", string(i),")"]), "ZZ")

)abbrev domain JFINT JuliaFractionInteger
++ Experimental domain for Julia Fraction Integers
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Fraction Integers
++  using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaFractionInteger() : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref    ==> make_jlref$Lisp
  Exports ==> Join(JuliaType, QuotientFieldCategory(JuliaInteger)) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    coerce  : Fraction(Integer) -> %
    coerce  : JuliaInteger -> %
    jfint   : Integer -> %
    jfint   : Fraction(Integer) -> %
  Implementation ==> LocalAlgebra(JuliaInteger,JuliaInteger) add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    fibinfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jlref(concat(["QQ(", jl_string_eval_string(tmp)$Lisp,")"]), "QQ")

    fibinbfunc(op,a,b) ==>
      tmp : String := concat(["string(", getind(a), op, getind(b),")"])
      jl_bool_eval_string(tmp)$Lisp

    fiunfunc(op, a) ==>
      tmp : String := concat(["string(", op, getind(a),")"])
      jlref(concat(["QQ(",jl_string_eval_string(tmp)$Lisp, ")"]),"QQ")

    0 == jlref("QQ(0)", "QQ")
    1 == jlref("QQ(1)", "QQ")

    x = y == fibinbfunc("==",x,y)
    x ~= y == fibinbfunc("!=",x,y)
    x < y == fibinbfunc("<",x,y)
    x > y == fibinbfunc(">",x,y)
    x >= y == fibinbfunc(">=",x,y)
    x <= y == fibinbfunc("<=",x,y)

    x + y == fibinfunc("+", x, y)
    x - y == fibinfunc("-", x, y)
    - x   == fiunfunc("-", x)
    x : % * y : % == fibinfunc("*", x, y)
    x : % / y : % == fibinfunc("/", x, y)
    x : % * y : JuliaInteger == fibinfunc("*", x, coerce(y))
    x : JuliaInteger * y : % == fibinfunc("*", coerce(x), y)

    x ^ y : NonNegativeInteger == fibinfunc("^", x, coerce(y pretend Integer))
    x ^ y : PositiveInteger == fibinfunc("^", x, coerce(y pretend Integer))

    x quo y == fibinfunc("รท", x, y)
    -- x quo y == ibinfunc("div", x, y)
    x rem y == fibinfunc("%", x, y)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)  == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["QQ(", jl_string_eval_string(tmp)$Lisp, ")"]),"QQ")

    coerce(i : Integer) ==
      jlref(concat(["QQ(", string i,")"]), "QQ")

    coerce(x : Fraction(Integer)) ==
      jlref(concat(["QQ(", string(numer x),
        "//", string(denom x),")"]), "QQ")

    coerce(i : %) : OutputForm == jlrefVal(i)
    jfint(i : Integer) == coerce(i)
    jfint(fi : Fraction Integer) == coerce(fi)


)abbrev domain JUP JuliaUnivariatePolynomial
++ Test package
JuliaUnivariatePolynomial(x : Symbol, R : Join(JuliaType, Ring)):
  Exports == Implementation where
    jlrefVal  ==> JLREFVAL$Lisp
    jlrefType ==> JLREFTYPE$Lisp
    jlrefId   ==> JLREFID$Lisp
    jlref     ==> make_jlref$Lisp 
    JINT      ==> JuliaInteger
    JI64      ==> JuliaInt64
    Exports ==> UnivariatePolynomialCategory(R) with
        jup     : UnivariatePolynomial(x,R) -> %
        ++ jup(p) converts the univariate polynomial p to
        ++ a Julia univariate polynomial.
        coerce  : Variable(x) -> %
        ++ coerce(x) converts the variable x to a Julia univariate polynomial.
        "*"       : (%, PositiveInteger) -> %
        "*"       : (%, NonNegativeInteger) -> %
    Implementation ==> add
        import from JuliaUtilityFunctions
        import from JuliaString
        --import from UnivariatePolynomial(x,R)
    
        jlInitialize(true)
        jl_eval_string("@suppress_err using Nemo")$Lisp
        -- jlref CL class
        Rep := SExpression


        spjs(str) ==> str pretend JuliaString
        var := string(x)

        getind(a) ==> concat(["getindex(", "refs,_"", jlrefId(a), "_")"])

        upbinfunc(op,a,b) ==>
          tmp : String := concat(["string(", getind(a), op, getind(b),")"])
          jlref(concat(["R(", jl_string_eval_string(tmp)$Lisp,")"]), "JUP")
        upbinbfunc(op,a,b) ==>
          tmp : String := concat([getind(a), op, getind(b)])
          jl_bool_eval_string(tmp)$Lisp
        upunfunc(op, a) ==>
          tmp : String := concat(["string(", op, getind(a),")"])
          jlref(concat(["R(",jl_string_eval_string(tmp)$Lisp, ")"]),"JUP")

        peval(expr) ==> concat(["eval(string(Meta.parse(_"",expr,"_")))"])

        if R is JuliaInteger then
            jl_eval_string(concat(["R,", string(x), "=polynomial_ring(ZZ,_"",
                string(x), "_")"])$String)$Lisp
            leadingCoefficient(p : %) ==
              tmp : String := concat(["leading_coefficient(", getind(p),")"])
              jlref(tmp, "ZZ")
        else if R is JuliaFractionInteger then
            jl_string_eval_string(concat(["R,", var, "=polynomial_ring(QQ,_"",
                var, "_")"])$String)$Lisp
            leadingCoefficient(p : %) ==
                tmp : String := concat(["leading_coefficient(", getind(p),")"])
                jlref(tmp, "QQ")
        else error "Unimplemented ring."

        1 == jlref("R(1)", "JUP")
        0 == jlref("R(0)", "JUP")
        - a == upunfunc("-",a)
        a : % = b : % == upbinbfunc("==",a,b)
        a : % ~= b : % == upbinbfunc("!=",a,b)
        a : % + b : % == upbinfunc("+",a,b)
        a : % - b : % == upbinfunc("-",a,b)
        a : % * b : % == upbinfunc("*",a,b)
        i : Integer  * b : % == upbinfunc("*", coerce(i)@%, b)
        a : % * i : Integer  == upbinfunc("*", a, coerce(i)@%)
        a : % * i : PositiveInteger  == upbinfunc("*", a, coerce(i pretend Integer)@%)
        a : % * i : NonNegativeInteger  == upbinfunc("*", a, coerce(i pretend Integer)@%)

        degree(p) ==
          tmp : String := concat(["degree(", getind(p),")"])
          jl_int64_eval_string(tmp)$Lisp   

        jup(up) : % ==
            p:= first(lines formatExpression(up::OutputForm)$Format1D)
            jlref(peval(p), "JUP")

        coerce(v : Variable(x)) == jlref(string(v::Symbol),"JUP")
        coerce(i : Integer) == jlref(concat(["R(",string(i),")"]),"JUP")
        coerce(p : %) : OutputForm == jlrefVal p
