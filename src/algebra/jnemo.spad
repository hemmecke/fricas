)abbrev category JRING JuliaRing
++ Category for Julia values
++ Author: G.Vanuxem
++ Date Created: March 2024
++ Description:
++  Parent category of Julia Ring elements.
JuliaRing() : Category == Join(JuliaType, Ring)

)abbrev domain JINT JuliaInteger
++ Experimental domain for Julia Integers
++ Author: G. Vanuxem
++ Date Created: Jan. 2023
++ Description:
++  This domain allows the manipulation of Julia Integers
++  using the Nemo package (FLINT based, among others).
JuliaInteger() : Exports == Implementation where
  JI64      ==> JuliaInt64
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaRing, OrderedSet,
          EuclideanDomain, ConvertibleTo(String)) with
    jlType  : % -> SExpression
    jlRef   : % -> SExpression
    jlValue : % -> SExpression
    jlId    : % -> SExpression
    "*"     : (%, Integer) -> %
    string  : % -> String
    coerce  : JI64 -> %
    coerce  : % -> JI64
    coerce  : % -> Integer
    coerce  : % -> Expression Integer
    coerce  : % -> AlgebraicNumber
    jint    : Integer -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp
 
    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])
    ibinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    iunfunc(func,a) ==> jlref(concat([func, "(", getind(a),")"]))
    ibinfunc(func,a,b) ==>
      jlref(concat([func, "(", getind(a), ",", getind(b),")"]))
    ibinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

  
    0 == jlref("zero(ZZ)")
    1 == jlref("one(ZZ)")

    x = y  == ibinbop("==",x,y)
    x ~= y == ibinbop("!=",x,y)
    x < y  == ibinbop("<",x,y)
    x > y  == ibinbop(">",x,y)
    x >= y == ibinbop(">=",x,y)
    x <= y == ibinbop("<=",x,y)

    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == ibinop("+", x, y)
    x - y == ibinop("-", x, y)
    - x   == iunfunc("-", x)
    x : % * y : % == ibinop("*", x, y)
    x : Integer * y : % == coerce(x) * y
    x  * y : Integer == jlref(concat([getind(x), "*", getind(coerce(y))]))
    x : Integer * y : % == jlref(concat([getind(coerce(x)), "*", getind(y)]))

    x ^ y : NonNegativeInteger ==
      ibinop("^", x, coerce(y pretend Integer))
    x ^ y : PositiveInteger ==
      ibinop("^", x, coerce(y pretend Integer))

    -- x quo y == ibinop("div", x, y)
    x quo y == ibinop("÷", x, y)
    x rem y == ibinop("%", x, y)
    gcd(a,b) == ibinfunc("gcd",a,b)
    lcm(a,b) == ibinfunc("lcm",a,b)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression
    string(x) : String == jlrefVal(x) pretend String

    convert(x) : String == jlrefVal(x) pretend String
    coerce(jsi : %): JI64 == 
        x := parsei(jlrefVal(jsi))
        coerce(x)
    coerce(i : Integer) ==
      jlref(concat(["ZZ(",string(i),")"]))
    coerce(i : %) : OutputForm == jlrefVal(i)
    coerce(x : %) : Integer  == parsei(jlrefVal x)
    coerce(x : %) : Expression(Integer)  ==
      coerce(parsei(jlrefVal x))$Expression(Integer)
    coerce(x : %) : AlgebraicNumber  ==
      coerce(parsei(jlrefVal x))$AlgebraicNumber
    jint(i : Integer) : % == jlref(concat(["ZZ(", string(i),")"]))

)abbrev domain JFINT JuliaFractionInteger
++ Experimental domain for Julia Fraction Integers
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Fraction Integers
++  using the Nemo package (FLINT based, among others).
JuliaFractionInteger() : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  JINT      ==> JuliaInteger
  Exports ==> Join(JuliaRing, QuotientFieldCategory(JuliaInteger),
            ConvertibleTo(String)) with
    jlType  : % -> SExpression
    jlRef   : % -> SExpression
    jlValue : % -> SExpression
    jlId    : % -> SExpression
    "*"     : (%, Integer) -> %
    string  : % -> String
    coerce  : Fraction(Integer) -> %
    coerce  : JuliaInteger -> %
    jfint   : Integer -> %
    jfint   : Fraction(Integer) -> %
  Implementation ==> LocalAlgebra(JuliaInteger,JuliaInteger) add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    spjs(str) ==> str pretend JuliaString
    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])
    fibinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    fiunfunc(func, a) ==> jlref(concat([func, "(", getind(a),")"]))
    fibinfunc(func,a,b) ==>
      jlref(concat([func, "(", getind(a), ",", getind(b),")"]))
    fibinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp



    0 == jlref("zero(QQ)")
    1 == jlref("one(QQ)")
    numer(x) == fiunfunc("numerator",x)
    denom(x) == fiunfunc("denominator",x)

    x = y  == fibinbop("==",x,y)
    x ~= y == fibinbop("!=",x,y)
    x < y  == fibinbop("<",x,y)
    x > y  == fibinbop(">",x,y)
    x >= y == fibinbop(">=",x,y)
    x <= y == fibinbop("<=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == fibinop("+", x, y)
    x - y == fibinop("-", x, y)
    - x   == fiunfunc("-", x)
    x : % * y : % == fibinop("*", x, y)
    x : % / y : % == fibinop("/", x, y)
    x : % * y : JuliaInteger == fibinop("*", x, y)
    x : JuliaInteger * y : % == fibinop("*", x, y)
    x : % * y : Integer == fibinop("*", x, coerce(y))
    x : Integer * y : % == fibinop("*", coerce(x), y)

    x ^ y : NonNegativeInteger == fibinop("^", x, coerce(y pretend Integer)@JINT)
    x ^ y : PositiveInteger == fibinop("^", x, coerce(y pretend Integer)@JINT)

    x quo y == fibinop("÷", x, y)
    -- x quo y == fibinop("div", x, y)
    x rem y == fibinop("%", x, y)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression
    string(x)  == jlrefVal(x) pretend String

    convert(x) : String == jlrefVal(x) pretend String
    coerce(x : JuliaInteger) : % ==
      jlref(concat(["QQ(", getind(x), ")"]))
    coerce(i : Integer) ==
      jlref(concat(["QQ(", string i,")"]))
    coerce(x : Fraction(Integer)) ==
      jlref(concat(["QQ(", string(numer x),
        "//", string(denom x),")"]))
    coerce(fi : %) : OutputForm ==
      jlRegexReplace(spjs(jlrefVal(fi)),
        jlRegex(jstring "//"),jlSubstitute(jstring "/")) pretend OutputForm
    jfint(i : Integer) == coerce(i)
    jfint(fi : Fraction Integer) == coerce(fi)


)abbrev domain JZMOD JuliaIntegerMod
++ Experimental domain for Galois Fields
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Galois field
++  elements using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaIntegerMod(p : PositiveInteger) : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaRing, CommutativeRing, Finite,
        ConvertibleTo(Integer), ConvertibleTo(String), StepThrough) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"      : (%, Integer) -> %
    "*"      : (Integer, %) -> %
    "*"      : (%, JuliaInteger) -> %
    "*"      : (JuliaInteger, %) -> %
    sqrt     : % -> %
    ++ sqrt(x) returns a square root of x.
    ++ Throw a Julia error if there is no square root and returns 0.
    "*"     : (%, Integer) -> %
    string  : % -> String
    coerce  : Integer -> %
    coerce  : JuliaInteger -> %
    jzmod   : Integer -> %
    jzmod   : JuliaInteger -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    import from JuliaInteger
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["JZMOD",string(p),",=residue_ring(ZZ,", string(p),")"]))$Lisp

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])
    zmodbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    zmodunfunc(op, a) ==> jlref(concat([op,"(" ,getind(a),")"]))
    zmodbinfunc(func,a,b) ==>
      jlref(concat([func, "(", getind(a), ",", getind(b),")"]))
    zmodbinbfunc(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp



    0 == jlref(concat(["zero(JZMOD",string(p),")"]))
    1 == jlref(concat(["one(JZMOD",string(p),")"]))
    init == 0
    nextItem(n) ==
        m := n+1
        m = 0 => "failed"
        m
    x = y == zmodbinbfunc("==",x,y)
    x ~= y == zmodbinbfunc("!=",x,y)
    -- TODO: add boolean unary operator (macro)?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == zmodbinop("+", x, y)
    x - y == zmodbinop("-", x, y)
    - x   == zmodunfunc("-", x)
    x : % * y : % == zmodbinop("*", x, y)
    x : % * y : JuliaInteger == zmodbinop("*", x, y)
    x : JuliaInteger * y : % == zmodbinop("*", x, y)
    x : % * y : Integer == zmodbinop("*", x, coerce(y)@JuliaInteger)
    x : Integer * y : % == zmodbinop("*", coerce(x)@JuliaInteger, y)

    x ^ y : NonNegativeInteger ==
      zmodbinop("^", x, coerce(y pretend Integer)@JuliaInteger)
    x ^ y : PositiveInteger ==
      zmodbinop("^", x, coerce(y pretend Integer)@JuliaInteger)
   
    -- zero?(x) ... else zmodunfunc("inv",x)
    -- Internal Error
    --  Cannot determine branch of Union.
    if p <= convert(max()$SingleInteger)@Integer then
      q := p::SingleInteger
      recip x ==
        zero?(y := convert(x)@Integer :: SingleInteger) => "failed"
        invmod(y, q)::Integer::%
    else
      recip x ==
        zero?(y := convert(x)@Integer) => "failed"
        invmod(y, p)::%
    
    -- Internal error: Cannot determine branch of Union.
    -- recip(x) == zmodunfunc("inv", x)

    size()           == p
    characteristic() == p
    lookup x == (zero? x => p; (convert(x)@Integer) :: PositiveInteger)
    random() == coerce(random(p)$Integer)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression
    string(x) : String == jlrefVal(x) pretend String

    convert(x) : String == jlrefVal(x) pretend String
    convert(x : %) : Integer == parsei string jlrefVal(x)
    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["JZMOD",string(p),"(", jl_string_eval_string(tmp)$Lisp, ")"]))

    coerce(i : Integer) ==
      jlref(concat(["JZMOD",string(p),"(", string(i), ")"]))

    coerce(i : %) : OutputForm == jlrefVal(i)
    jzmod(i : Integer) == coerce(i)
    jzmod(ji : JuliaInteger) == coerce(ji)


)abbrev domain JGF JuliaGaloisField
++ Experimental domain for Galois Fields
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Galois field
++  elements using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaGaloisField(p : PositiveInteger) : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  SUP       ==> SparseUnivariatePolynomial
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaRing, FiniteFieldCategory, 
                   FiniteAlgebraicExtensionField(%),
                   ConvertibleTo(Integer), ConvertibleTo(String)) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"      : (%, JuliaInteger) -> %
    "*"      : (JuliaInteger, %) -> %
    "*"      : (Integer, %) -> %
    "*"      : (%, Integer) -> %
    sqrt     : % -> %
    ++ sqrt(x) returns a square root of x.
    ++ Throw a Julia error if there is no square root and returns 0.
    string  : % -> String
    coerce  : Integer -> %
    coerce  : JuliaInteger -> %
    jgf   : Integer -> %
    jgf   : JuliaInteger -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["JGF",string(p),"=GF(", string(p),")"]))$Lisp

    -- jlref type
    JGF ==> concat(["JGF(",string(p),")"])

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    jgfbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    jgfunfunc(op, a) ==> jlref(concat([op,"(" ,getind(a),")"]))
    jgfbinfunc(func,a,b) ==>
      jlref(concat([func, "(", getind(a), ",", getind(b),")"]))
    jgfbinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

    0 == jlref(concat(["zero(","JGF",string(p),")"]))
    1 == jlref(concat(["one(","JGF",string(p),")"]))

    x = y == jgfbinbop("==",x,y)
    x ~= y == jgfbinbop("!=",x,y)
  
    -- TODO: add boolean unary operator (macro)?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == jgfbinop("+", x, y)
    x - y == jgfbinop("-", x, y)
    - x   == jgfunfunc("-", x)
    x : % * y : % == jgfbinop("*", x, y)
    x : % * y : JuliaInteger == jgfbinop("*", x, y)
    x : JuliaInteger * y : % == jgfbinop("*", x, y)
    x : % * y : Integer == jgfbinop("*", x, coerce(y)@JuliaInteger)
    x : Integer * y : % == jgfbinop("*", coerce(x)@JuliaInteger, y)
    x : % / y : % == jgfbinop("/", x, y)


    x ^ y : NonNegativeInteger ==
      jgfbinop("^", x, coerce(y pretend Integer)@JuliaInteger)
    x ^ y : PositiveInteger ==
      jgfbinop("^", x, coerce(y pretend Integer)@JuliaInteger)

    x quo y == jgfbinop("÷", x, y)
    -- x quo y == jgfbinop("div", x, y)
    x rem y == jgfbinop("%", x, y)

    if p <= convert(max()$SingleInteger)@Integer then
      q := p::SingleInteger
      recip x ==
        zero?(y := convert(x)@Integer :: SingleInteger) => "failed"
        invmod(y, q)::Integer::%
    else
      recip x ==
        zero?(y := convert(x)@Integer) => "failed"
        invmod(y, p)::%

    -- TODO
    -- Internal error: Cannot determine branch of Union.
    -- recip(x) == zero? ... else jgfbinfunc("inv", x)

    generator() == 1
    normalElement() == 1
    createNormalElement() == 1
    characteristic() == p pretend NNI
    size() == p pretend NNI
    representationType() == "prime"
    degree(x) : PI == 1$PositiveInteger
    extensionDegree() : PI == 1$PositiveInteger
    charthRoot(x : %) : % == x
    inGroundField?(x)  == true
    coordinates(x : %) : Vector(%) == new(1, x)$(Vector %)
    represents(v)  == v(1)
    retract(x) == x
    retractIfCan(x) == x

    basis() == new(1, 1::%)$(Vector %)
    basis(n : PI) ==
      n = 1 => basis()
      error("basis: argument must divide extension degree")

    definingPolynomial() ==
      monomial(1, 1)$(SUP %) - monomial(1, 0)$(SUP %)

    minimalPolynomial(x) ==
      monomial(1, 1)$(SUP %) - monomial(x, 0)$(SUP %)

    sqrt(x) == jgfunfunc("sqrt", x)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression
    string(x) : String == jlrefVal(x) pretend String

    convert(x) : String == jlrefVal(x) pretend String
    convert(x : %) : Integer == parsei string jlrefVal(x)
    coerce(x : JuliaInteger) : % ==
      jlref(concat(["JGF",string(p),"(", getind(x) , ")"]))
    coerce(i : Integer) ==
      jlref(concat(["JGF",string(p),"(", string(i), ")"]))
    coerce(i : %) : OutputForm == jlrefVal(i)
    jgf(i : Integer) == coerce(i)
    jgf(ji : JuliaInteger) == coerce(ji)

)abbrev domain JRF JuliaRealField
++ Experimental domain for Julia Real Field based on the Arb
++ library.
++ Author: G. Vanuxem
++ Date Created: March. 2024
++ Keywords: float, floating point, number, real
++ Description:
++ \spadtype{JuliaRealField} implements arbitrary precision floating
++ point arithmetic using Julia Real Field (Arb based).
JuliaRealField() : Exports == Implementation where
  JI64      ==> JuliaInt64
  PI        ==> PositiveInteger
  JF64      ==> JuliaFloat64
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  Exports ==> Join(JuliaRing, ConvertibleTo(InputForm), CommutativeRing,
            FloatingPointSystem, arbitraryPrecision, ElementaryFunctionCategory,
            TranscendentalFunctionCategory, DifferentialRing,
            ConvertibleTo(String)) with
            -- SpecialFunctionCategory) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    expm1   :  % -> %
    ++ expm1(x) computes accurately e^x-1. It avoids the loss of precision
    ++ involved in the direct evaluation of exp(x)-1 for small values of x.
    log1p   : % -> %
    ++ log1p(x) logarithm of 1+x computed accurately.
    exp1    : () -> %
    ++ exp1() returns the JuliaFloat ℯ (%e).
    pi      : () -> %
    ++ pi() returns the JuliaFloat π (%pi).
    atan : % -> %
    ++ atan(x) computes the inverse tangent of x.
    atan : (%, %) -> %
    ++ atan(x, y) computes the inverse tangent of x/y.
    "*"      : (%, Integer) -> %
    "/"      : (Integer, %) -> %
    sqrt     : % -> %
    -- coerce   : JI64 -> %
    coerce   : JF64 -> %
    coerce   : String -> %
    retractIfCan  : % -> JF64
    string   : % -> String
    jrf   : String -> %
    jrf   : Integer -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    import from JuliaFloat64
    import from JuliaInteger
    import from JuliaFractionInteger
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp
 
    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["JRF","=RealField()"]))$Lisp

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    jfbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    jfbinfunc(func,a,b) ==>
      jlref(concat([func, "(", getind(a), ",", getind(b),")"]))
    jfbinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp
    jfunfunc(opfunc, a) ==> jlref(concat([opfunc, "(", getind(a),")"]))

    precision() ==
      jl_int64_eval_string("precision(JRF)")$Lisp pretend PI
    precision(p : PI) ==
      oldp := precision()
      jl_eval_string(concat(["set_precision!(JRF,",string(p),")"]))$Lisp
      oldp
  
    0    == jlref("zero(JRF)")
    1    == jlref("one(JRF)")
    pi() == jlref("JRF(π)")
    exp1() == jlref("JRF(ℯ)")

    x = y  == jfbinbop("==",x,y)
    x ~= y == jfbinbop("!=",x,y)
    x < y  == jfbinbop("<",x,y)
    x > y  == jfbinbop(">",x,y)
    x >= y == jfbinbop(">=",x,y)
    x <= y == jfbinbop("<=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == jfbinop("+", x, y)
    x - y == jfbinop("-", x, y)
    - x   == jfunfunc("-", x)
    x : % * y : % == jfbinop("*", x, y)
    x : % / y : % == jfbinop("/", x, y)

    x : Integer * y : % == jlref(concat([getind(coerce(x)), "*", getind(y)]))
    x : % * y : Integer == jlref(concat([getind(x), "*", getind(coerce(y))]))
    x : Integer / y : % == jlref(concat([getind(coerce(x)), "/", getind(y)]))
    x : % / y : Integer == jlref(concat([getind(x), "/", getind(coerce(y))]))
    
    x ^ y : NonNegativeInteger ==
      jfbinop("^", x, coerce(y pretend Integer))
    x ^ y : PositiveInteger ==
      jfbinop("^", x, coerce(y pretend Integer))

    -- x quo y == jfbinop("div", x, y)
    x quo y == jfbinop("÷", x, y)
    x rem y == jfbinop("%", x, y)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    sqrt(x)  == jfunfunc("√",x)
    exp(x)   == jfunfunc("exp",x)
    log(x)   == jfunfunc("log",x)
    expm1(x) == jfunfunc("expm1",x)
    log1p(x) == jfunfunc("log1p",x)


    sin(x)  == jfunfunc("sin",x)
    cos(x)  == jfunfunc("cos",x)
    tan(x)  == jfunfunc("tan",x)
    sec(x)  == jfunfunc("sec",x)
    cot(x)  == jfunfunc("cot",x)
    csc(x)  == jfunfunc("csc",x)

    asin(x)  == jfunfunc("asin",x)
    acos(x)  == jfunfunc("acos",x)
    atan(x)  == jfunfunc("atan",x)
    atan(x,y) == jfbinfunc("atan",x,y)
    asec(x)  == jfunfunc("asec",x)
    acot(x)  == jfunfunc("acot",x)
    acsc(x)  == jfunfunc("acsc",x)

    sinh(x)  == jfunfunc("sinh",x)
    cosh(x)  == jfunfunc("cosh",x)
    tanh(x)  == jfunfunc("tanh",x)
    sech(x)  == jfunfunc("sech",x)
    coth(x)  == jfunfunc("coth",x)
    csch(x)  == jfunfunc("csch",x)

    asinh(x)  == jfunfunc("asinh",x)
    acosh(x)  == jfunfunc("acosh",x)
    atanh(x)  == jfunfunc("atanh",x)
    asech(x)  == jfunfunc("asech",x)
    acoth(x)  == jfunfunc("acoth",x)
    acsch(x)  == jfunfunc("acsch",x)

    convert(x) : InputForm ==
      jl_string_eval_string(concat(["string(", getind(x),")"]))$Lisp

    convert(x) : String ==
      jl_string_eval_string(concat(["string(", getind(x),")"]))$Lisp

    string(x) : String ==
      jl_string_eval_string(concat(["string(", getind(x),")"]))$Lisp
    
    

    coerce(jf : JF64) : % == jlref(concat(["JRF(_"", convert(jf),"_")"]))
    coerce(i : Integer) == jlref(concat(["JRF(_"", string(i),"_")"]))
    coerce(s : String) == jlref(concat(["JRF(_"", s,"_")"]))
    coerce(i : %) : OutputForm == jlrefVal(i)
    jrf(s : String) : % == jlref(concat(["JRF(_"", s,"_")"]))
    jrf(i : Integer) : % == jlref(concat(["JRF(_"", string(i),"_")"]))

)abbrev domain JCF JuliaComplexField
++ Domain for Julia complex field based on the Arb
++ library.
++ Author: G. Vanuxem
++ Date Created: March. 2024
++ Keywords: float, floating point, number, real
++ Description:
++ \spadtype{JuliaRealField} implements arbitrary precision floating
++ point arithmetic using Julia Real Field (Arb based).
JuliaComplexField() : Exports == Implementation where
  JI64      ==> JuliaInt64
  PI        ==> PositiveInteger
  JF64      ==> JuliaFloat64
  JRF       ==> JuliaRealField
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  Exports ==> Join(JuliaRing, ConvertibleTo(InputForm), CommutativeRing,
            ComplexCategory(JuliaRealField), arbitraryPrecision,
            ElementaryFunctionCategory, TranscendentalFunctionCategory,
            DifferentialRing, ConvertibleTo(String)) with
            -- SpecialFunctionCategory) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    expm1   :  % -> %
    ++ expm1(x) computes accurately e^x-1. It avoids the loss of precision
    ++ involved in the direct evaluation of exp(x)-1 for small values of x.
    log1p   : % -> %
    ++ log1p(x) logarithm of 1+x computed accurately.
    exp1    : () -> %
    ++ exp1() returns the JuliaFloat ℯ (%e).
    pi      : () -> %
    ++ pi() returns the JuliaFloat π (%pi).
    atan : % -> %
    ++ atan(x) computes the inverse tangent of x.
    atan : (%, %) -> %
    ++ atan(x, y) computes the inverse tangent of x/y.
    "*"      : (%, Integer) -> %
    "/"      : (Integer, %) -> %
    "/"      : (%, Integer) -> %
    sqrt     : % -> %
    -- coerce   : JI64 -> %
    precision : () -> PI
    precision : PI -> PI
    coerce   : JF64 -> %
    coerce   : String -> %
    retractIfCan  : % -> JF64
    string   : % -> String
    jcf   : String -> %
    jcf   : (String, String) -> %
    jcf   : Integer -> %
    jcf   : (Integer, Integer) -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    import from JuliaFloat64
    import from JuliaInteger
    import from JuliaFractionInteger
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp
 
    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["JCF","= ComplexField()"]))$Lisp

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    jfbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    jfbinfunc(func,a,b) ==>
      jlref(concat([func, "(", getind(a), ",", getind(b),")"]))
    jfbinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp
    jfunfunc(opfunc, a) ==> jlref(concat([opfunc, "(", getind(a),")"]))

    precision() ==
      jl_int64_eval_string("precision(JCF)")$Lisp pretend PI
    precision(p : PI) ==
      oldp := precision()
      jl_eval_string(concat(["set_precision!(JCF,",string(p),")"]))$Lisp
      oldp
  
    0    == jlref("zero(JCF)")
    1    == jlref("one(JCF)")
    real(x) == jlref(concat(["real(", getind(x),")"]))
    imag(x) == jlref(concat(["imag(", getind(x),")"]))
    pi() == jlref("JCF(π)")
    exp1() == jlref("JCF(ℯ)")

    x = y  == jfbinbop("==",x,y)
    x ~= y == jfbinbop("!=",x,y)

    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == jfbinop("+", x, y)
    x - y == jfbinop("-", x, y)
    - x   == jfunfunc("-", x)
    x : % * y : % == jfbinop("*", x, y)
    x : % / y : % == jfbinop("/", x, y)

    x : Integer * y : % == jlref(concat([getind(coerce(x)), "*", getind(y)]))
    x : % * y : Integer == jlref(concat([getind(x), "*", getind(coerce(y))]))
    x : Integer / y : % == jlref(concat([getind(coerce(x)), "/", getind(y)]))
    x : % / y : Integer == jlref(concat([getind(x), "/", getind(coerce(y))]))
    
    x ^ y : NonNegativeInteger ==
      jfbinop("^", x, coerce(y pretend Integer))
    x ^ y : PositiveInteger ==
      jfbinop("^", x, coerce(y pretend Integer))

    -- x quo y == jfbinop("div", x, y)
    x quo y == jfbinop("÷", x, y)
    x rem y == jfbinop("%", x, y)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    sqrt(x)  == jfunfunc("√",x)
    exp(x)   == jfunfunc("exp",x)
    log(x)   == jfunfunc("log",x)
    expm1(x) == jfunfunc("expm1",x)
    log1p(x) == jfunfunc("log1p",x)


    sin(x)  == jfunfunc("sin",x)
    cos(x)  == jfunfunc("cos",x)
    tan(x)  == jfunfunc("tan",x)
    sec(x)  == jfunfunc("sec",x)
    cot(x)  == jfunfunc("cot",x)
    csc(x)  == jfunfunc("csc",x)

    sinh(x)  == jfunfunc("sinh",x)
    cosh(x)  == jfunfunc("cosh",x)
    tanh(x)  == jfunfunc("tanh",x)
    sech(x)  == jfunfunc("sech",x)
    coth(x)  == jfunfunc("coth",x)
    csch(x)  == jfunfunc("csch",x)

    convert(x) : InputForm ==
      jl_string_eval_string(concat(["string(", getind(x),")"]))$Lisp

    convert(x) : String ==
      jl_string_eval_string(concat(["string(", getind(x),")"]))$Lisp

    string(x) : String ==
      jl_string_eval_string(concat(["string(", getind(x),")"]))$Lisp
    
    
    complex(r:JRF,i:JRF) == jlref(concat(["JCF(", getind(r),",",getind(i),")"]))
    coerce(jf : JF64) : % == jlref(concat(["JCF(_"", convert(jf),"_")"]))
    coerce(i : Integer) == jlref(concat(["JCF(_"", string(i),"_")"]))
    coerce(s : String) == jlref(concat(["JCF(_"", s,"_")"]))
    coerce(i : %) : OutputForm == jlrefVal(i)
    jcf(s : String) : % == jlref(concat(["JCF(_"", s,"_")"]))
    jcf(r : String, i : String) : % ==
      jlref(concat(["JCF(_"", r, "_",_"", i, "_")"]))
    jcf(i : Integer) : % == jlref(concat(["JCF(_"", string(i),"_")"]))
    jcf(r : Integer, i : Integer) : % ==
      jlref(concat(["JCF(_"", string(r), "_",_"" , string(i),"_")"]))



)abbrev domain JUP JuliaUnivariatePolynomial
++ Univariate polynomial domain using the Nemo package from Julia
++ Author: G. vanuxem
++ Purpose: Experimentation.
JuliaUnivariatePolynomial(x : Symbol, R : JuliaRing):
  Exports == Implementation where
    jlrefType ==> JLREFTYPE$Lisp
    jlrefId   ==> JLREFID$Lisp
    jlrefVal  ==> JLREFVAL$Lisp
    jlref     ==> make_jlref$Lisp 
    JINT      ==> JuliaInteger
    JFINT     ==> JuliaFractionInteger
    JRF       ==> JuliaRealField
    JCF       ==> JuliaComplexField
    JI64      ==> JuliaInt64
    INT       ==> Integer
    PI        ==> PositiveInteger
    NNI       ==> NonNegativeInteger
    Exports ==> Join(JuliaRing, UnivariatePolynomialCategory(R),
                    ConvertibleTo(String)) with
        jlType   : % -> SExpression
        jlValue  : % -> SExpression
        jlId     : % -> SExpression
        jlRef   : % -> SExpression
        jup     : UnivariatePolynomial(x,R) -> %
        ++ jup(p) converts the univariate polynomial p to
        ++ a Julia univariate polynomial.
        coerce   : Variable(x) -> %
        ++ coerce(x) converts the variable x to a Julia univariate polynomial.
        "*"      : (%, PositiveInteger) -> %
        "*"      : (%, NonNegativeInteger) -> %
        string   : % -> String
    Implementation ==> add
        import from JuliaUtilityFunctions
        import from String
    
        jlInitialize(true)
        jl_eval_string("@suppress_err using Nemo")$Lisp
        Rep := SExpression

        jlId(p)    == jlrefId p
        jlValue(p) == jlrefVal p
        jlType(p)  == jlrefType p
        jlRef(p)   == p pretend SExpression

        spjs(str) ==> str pretend JuliaString

        getind(a) ==> concat(["getindex(", "refs,_"", jlrefId(a), "_")"])

        upbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
        upunfunc(op, a) ==> jlref(concat([op, "(", getind(a),")"]))
        upbinfunc(func,a,b) ==> 
          jlref(concat([func, "(", getind(a), ",", getind(b), ")"]))
        upbinbop(op,a,b) ==>
          jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

        if R is JuliaInteger then
          jl_eval_string(concat(["R,", string(x), "=polynomial_ring(ZZ,_"",
            string(x), "_")"])$String)$Lisp
          monomial(coef,exp) ==
            jlref(concat([string(coef)$JINT,"*", string(x), "^",
              string(exp pretend Integer)]))
          coerce(p : %) : OutputForm == jlrefVal(p)
        else if R is JuliaFractionInteger then
          jl_eval_string(concat(["R,", string(x), "=polynomial_ring(QQ,_"",
            string(x), "_")"])$String)$Lisp
          monomial(coef,exp) ==
            jlref(concat([string(coef)$JFINT,"*", string(x), "^",
              string(exp pretend Integer)]))
          coerce(p : %) : OutputForm ==
            jlRegexReplace(spjs(jlrefVal(p)),
              jlRegex(jstring "//"),jlSubstitute(jstring "/")) pretend OutputForm
        -- Awful workaround (differentiate JZMOD vs. JGF)
        else if R has FiniteFieldCategory and R has ConvertibleTo(String) then
          jl_eval_string(concat(["R,", string(x), "=polynomial_ring(",
            concat(["JGF",string(size()$R pretend INT)])$String,
              ",_"", string(x), "_")"])$String)$Lisp
          monomial(coef,exp) ==
            jlref(concat([convert(coef),"*", string(x), "^",
              string(exp pretend Integer)]))
          coerce(p : %) : OutputForm == jlrefVal(p)
        else if R has Finite and R has ConvertibleTo(String) then
          jl_eval_string(concat(["R,", string(x), "=polynomial_ring(",
            concat(["JZMOD",string(size()$R pretend INT)])$String,
              ",_"", string(x), "_")"])$String)$Lisp
          monomial(coef,exp) ==
            jlref(concat([convert(coef),"*", string(x), "^",
              string(exp pretend Integer)]))
          coerce(p : %) : OutputForm == jlrefVal(p)  
        else if R is JuliaRealField then
          jl_eval_string(concat(["R,", string(x), "=polynomial_ring(JRF,_"",
              string(x), "_")"])$String)$Lisp
          monomial(coef,exp) ==
            jlref(concat([string(coef)$JRF,"*", string(x), "^",
                  string(exp pretend Integer)]))
          coerce(p : %) : OutputForm == jlrefVal(p)
        else if R is JuliaComplexField then
          jl_eval_string(concat(["R,", string(x), "=polynomial_ring(JCF,_"",
              string(x), "_")"])$String)$Lisp
          monomial(coef,exp) ==
            jlref(concat([string(coef)$JCF,"*", string(x), "^",
                  string(exp pretend Integer)]))
          coerce(p : %) : OutputForm == jlrefVal(p)
        else error "Unimplemented ring."

        0 == jlref("zero(R)")
        1 == jlref("one(R)")
        - a == upunfunc("-",a)
        a : % = b : % == upbinbop("==",a,b)
        a : % ~= b : % == upbinbop("!=",a,b)
        a : % + b : % == upbinop("+",a,b)
        a : % - b : % == upbinop("-",a,b)
        a : % * b : % == upbinop("*",a,b)
        a : R * b : % == upbinop("*",a,b)
        i : Integer  * b : % == upbinop("*", coerce(i)@JINT, b)
        fi : Fraction(INT) * b : % == upbinop("*", coerce(fi)@JFINT, b)
        a : % * i : INT  == upbinop("*", a, coerce(i))
        a : % * i : PI  == upbinop("*", a, coerce(i pretend Integer)@JINT)
        a : % * i : NNI  == upbinop("*", a, coerce(i pretend Integer)@JINT)
        a : % ^ i : PI  == upbinop("^", a, coerce(i pretend Integer)@JINT)
        a : % ^ i : NNI  == upbinop("^", a, coerce(i pretend Integer)@JINT)

        reductum(p) == upunfunc("tail",p)
        gcd(p1,p2)  == upbinfunc("gcd",p1,p2)

        degree(p) == jl_int64_eval_string(concat(["degree(", getind(p),")"]))$Lisp   
        leadingCoefficient(p : %) ==
            jlref(concat(["leading_coefficient(", getind(p),")"]))
        jup(up) : % ==
            p:= first(lines formatExpression(up::OutputForm)$Format1D)
            jlref(p)
        string(p)  == jlrefVal(p) pretend String

        convert(p) : String == jlrefVal(p) pretend String
        coerce(v : Variable(x)) == jlref(string(v::Symbol))
        coerce(i : Integer) == jlref(concat(["R(",string(i),")"]))
