)abbrev domain JINT JuliaInteger
++ Experimental domain for Julia Integers
++ Author: G. Vanuxem
++ Date Created: Jan. 2023
++ Description:
++  This domain allows the manipulation of Julia Integers
++  using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaInteger() : Exports == Implementation where
  JI64      ==> JuliaInt64
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, OrderedSet, EuclideanDomain) with
    jlType  : % -> SExpression
    jlRef   : % -> SExpression
    jlValue : % -> SExpression
    jlId    : % -> SExpression
    "*"     : (%, Integer) -> %
    coerce  : JI64 -> %
    coerce  : % -> JI64
    coerce  : % -> Integer
    coerce  : % -> Expression Integer
    coerce  : % -> AlgebraicNumber
    jint    : Integer -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp
 
    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])
    ibinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    iunfunc(op, a) ==> jlref(concat([op, "(", getind(a),")"]))
    ibinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

  
    0 == jlref("ZZ(0)")
    1 == jlref("ZZ(1)")

    x = y  == ibinbop("==",x,y)
    x ~= y == ibinbop("!=",x,y)
    x < y  == ibinbop("<",x,y)
    x > y  == ibinbop(">",x,y)
    x >= y == ibinbop(">=",x,y)
    x <= y == ibinbop("<=",x,y)

    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == ibinop("+", x, y)
    x - y == ibinop("-", x, y)
    - x   == iunfunc("-", x)
    x : % * y : % == ibinop("*", x, y)
    x : Integer * y : % == coerce(x) * y
    x  * y : Integer == x * coerce(y)

    x : Integer * y : % ==
      i : % := coerce(x)
      tmp : String := concat(["string(", getind(i), "*", getind(y),")"])
      jlref(concat(["ZZ(", jl_string_eval_string(tmp)$Lisp,")"]))

    x ^ y : NonNegativeInteger ==
      ibinop("^", x, coerce(y pretend Integer))
    x ^ y : PositiveInteger ==
      ibinop("^", x, coerce(y pretend Integer))

    -- x quo y == ibinop("div", x, y)
    x quo y == ibinop("รท", x, y)
    x rem y == ibinop("%", x, y)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(jsi : %): JI64 ==
        x := parsei(jlrefVal(jsi))
        coerce(x)
    coerce(i : Integer) ==
      jlref(concat(["ZZ(",string(i),")"]))
    coerce(i : %) : OutputForm == jlrefVal(i)
    coerce(x : %) : Integer  == integer(jlrefVal x)
    coerce(x : %) : Expression(Integer)  ==
      coerce(parsei(jlrefVal x))$Expression(Integer)
    coerce(x : %) : AlgebraicNumber  ==
      coerce(parsei(jlrefVal x))$AlgebraicNumber
    jint(i : Integer) : % == jlref(concat(["ZZ(", string(i),")"]))

)abbrev domain JFINT JuliaFractionInteger
++ Experimental domain for Julia Fraction Integers
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Fraction Integers
++  using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaFractionInteger() : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  JINT      ==> JuliaInteger
  Exports ==> Join(JuliaType, QuotientFieldCategory(JuliaInteger)) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"     : (%, Integer) -> %
    coerce  : Fraction(Integer) -> %
    coerce  : JuliaInteger -> %
    jfint   : Integer -> %
    jfint   : Fraction(Integer) -> %
  Implementation ==> LocalAlgebra(JuliaInteger,JuliaInteger) add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])
    fibinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    fiunfunc(op, a) ==> jlref(concat([op, "(", getind(a),")"]))
    fibinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp



    0 == jlref("QQ(0)")
    1 == jlref("QQ(1)")

    x = y  == fibinbop("==",x,y)
    x ~= y == fibinbop("!=",x,y)
    x < y  == fibinbop("<",x,y)
    x > y  == fibinbop(">",x,y)
    x >= y == fibinbop(">=",x,y)
    x <= y == fibinbop("<=",x,y)
    -- TODO: add boolean unary operator macro?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == fibinop("+", x, y)
    x - y == fibinop("-", x, y)
    - x   == fiunfunc("-", x)
    x : % * y : % == fibinop("*", x, y)
    x : % / y : % == fibinop("/", x, y)
    x : % * y : JuliaInteger == fibinop("*", x, y)
    x : JuliaInteger * y : % == fibinop("*", x, y)
    x : % * y : Integer == fibinop("*", x, coerce(y))
    x : Integer * y : % == fibinop("*", coerce(x), y)

    x ^ y : NonNegativeInteger == fibinop("^", x, coerce(y pretend Integer)@JINT)
    x ^ y : PositiveInteger == fibinop("^", x, coerce(y pretend Integer)@JINT)

    x quo y == fibinop("รท", x, y)
    -- x quo y == fibinop("div", x, y)
    x rem y == fibinop("%", x, y)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)  == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["QQ(", jl_string_eval_string(tmp)$Lisp, ")"]))

    coerce(i : Integer) ==
      jlref(concat(["QQ(", string i,")"]))

    coerce(x : Fraction(Integer)) ==
      jlref(concat(["QQ(", string(numer x),
        "//", string(denom x),")"]))

    coerce(i : %) : OutputForm == jlrefVal(i)
    jfint(i : Integer) == coerce(i)
    jfint(fi : Fraction Integer) == coerce(fi)


)abbrev domain JZMOD JuliaIntegerMod
++ Experimental domain for Galois Fields
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Galois field
++  elements using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaIntegerMod(p : PositiveInteger) : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, CommutativeRing, Finite,
        ConvertibleTo Integer, StepThrough) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"      : (%, Integer) -> %
    "*"      : (Integer, %) -> %
    "*"      : (%, JuliaInteger) -> %
    "*"      : (JuliaInteger, %) -> %
    sqrt     : % -> %
    ++ sqrt(x) returns a square root of x.
    ++ Throw a Julia error if there is no square root and returns 0.
    "*"     : (%, Integer) -> %
    coerce  : Integer -> %
    coerce  : JuliaInteger -> %
    jzmod   : Integer -> %
    jzmod   : JuliaInteger -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    import from JuliaInteger
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["JZMOD",string(p),",=residue_ring(ZZ,", string(p),")"]))$Lisp

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])
    zmodbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    zmodunfunc(op, a) ==> jlref(concat([op,"(" ,getind(a),")"]))
    zmodbinbfunc(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp



    0 == jlref(concat(["zero(JZMOD",string(p),")"]))
    1 == jlref(concat(["one(JZMOD",string(p),")"]))
    init == 0
    nextItem(n) ==
        m := n+1
        m = 0 => "failed"
        m
    x = y == zmodbinbfunc("==",x,y)
    x ~= y == zmodbinbfunc("!=",x,y)
    -- TODO: add boolean unary operator (macro)?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == zmodbinop("+", x, y)
    x - y == zmodbinop("-", x, y)
    - x   == zmodunfunc("-", x)
    x : % * y : % == zmodbinop("*", x, y)
    x : % * y : JuliaInteger == zmodbinop("*", x, y)
    x : JuliaInteger * y : % == zmodbinop("*", x, y)
    x : % * y : Integer == zmodbinop("*", x, coerce(y)@JuliaInteger)
    x : Integer * y : % == zmodbinop("*", coerce(x)@JuliaInteger, y)

    x ^ y : NonNegativeInteger ==
      zmodbinop("^", x, coerce(y pretend Integer)@JuliaInteger)
    x ^ y : PositiveInteger ==
      zmodbinop("^", x, coerce(y pretend Integer)@JuliaInteger)
   
    -- zero?(x) ... else zmodunfunc("inv",x)
    -- Internal Error
    --  Cannot determine branch of Union.
    if p <= convert(max()$SingleInteger)@Integer then
      q := p::SingleInteger
      recip x ==
        zero?(y := convert(x)@Integer :: SingleInteger) => "failed"
        invmod(y, q)::Integer::%
    else
      recip x ==
        zero?(y := convert(x)@Integer) => "failed"
        invmod(y, p)::%
    
    -- Internal error: Cannot determine branch of Union.
    -- recip(x) == zmodunfunc("inv", x)

    size()           == p
    characteristic() == p
    lookup x == (zero? x => p; (convert(x)@Integer) :: PositiveInteger)
    random() == coerce(random(p)$Integer)
    
    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    convert(x : %) : Integer == parsei string jlrefVal(x)
    coerce(x : JuliaInteger) : % ==
      tmp : String := concat(["string(", getind(x), ")"])
      jlref(concat(["JZMOD",string(p),"(", jl_string_eval_string(tmp)$Lisp, ")"]))

    coerce(i : Integer) ==
      jlref(concat(["JZMOD",string(p),"(", string(i), ")"]))

    coerce(i : %) : OutputForm == jlrefVal(i)
    jzmod(i : Integer) == coerce(i)
    jzmod(ji : JuliaInteger) == coerce(ji)


)abbrev domain JGF JuliaGaloisField
++ Experimental domain for Galois Fields
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Description:
++  This domain allows the manipulation of Julia Galois field
++  elements using the Nemo package (FLINT based, among others).
++ Purpose: Experimentation.
JuliaGaloisField(p : PositiveInteger) : Exports == Implementation where
  jlrefVal  ==> JLREFVAL$Lisp
  jlrefType ==> JLREFTYPE$Lisp
  jlrefId   ==> JLREFID$Lisp
  jlref     ==> make_jlref$Lisp
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  SUP       ==> SparseUnivariatePolynomial
  parsei    ==> parse_integer$ScanningUtilities
  Exports ==> Join(JuliaType, FiniteFieldCategory,
          FiniteAlgebraicExtensionField(%), ConvertibleTo(Integer)) with
    jlType   : % -> SExpression
    jlRef    : % -> SExpression
    jlValue  : % -> SExpression
    jlId     : % -> SExpression
    "*"      : (%, JuliaInteger) -> %
    "*"      : (JuliaInteger, %) -> %
    "*"      : (Integer, %) -> %
    "*"      : (%, Integer) -> %
    sqrt     : % -> %
    ++ sqrt(x) returns a square root of x.
    ++ Throw a Julia error if there is no square root and returns 0.
    coerce  : Integer -> %
    coerce  : JuliaInteger -> %
    jgf   : Integer -> %
    jgf   : JuliaInteger -> %
  Implementation ==> add
    import from JuliaUtilityFunctions
    import from String
    
    jlInitialize(true)
    jl_eval_string("@suppress_err using Nemo")$Lisp

    Rep := SExpression

    -- initialize
    jl_eval_string(concat(["GF",string(p),"=GF(", string(p),")"]))$Lisp

    -- jlref type
    GF ==> concat(["GF(",string(p),")"])

    getind(a) ==> concat(["getindex(", "refs,_"", jlrefId a, "_")"])

    jgfbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
    jgfunfunc(op, a) ==> jlref(concat([op,"(" ,getind(a),")"]))
    jgfbinbop(op,a,b) ==>
      jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp



    0 == jlref(concat(["zero(","GF",string(p),")"]))
    1 == jlref(concat(["one(","GF",string(p),")"]))

    x = y == jgfbinbop("==",x,y)
    x ~= y == jgfbinbop("!=",x,y)
  
    -- TODO: add boolean unary operator (macro)?
    zero? x ==
      jl_bool_eval_string(concat(["iszero(", getind(x),")"]))$Lisp
    one? x ==
      jl_bool_eval_string(concat(["isone(", getind(x),")"]))$Lisp

    x + y == jgfbinop("+", x, y)
    x - y == jgfbinop("-", x, y)
    - x   == jgfunfunc("-", x)
    x : % * y : % == jgfbinop("*", x, y)
    x : % * y : JuliaInteger == jgfbinop("*", x, y)
    x : JuliaInteger * y : % == jgfbinop("*", x, y)
    x : % * y : Integer == jgfbinop("*", x, coerce(y)@JuliaInteger)
    x : Integer * y : % == jgfbinop("*", coerce(x)@JuliaInteger, y)
    x : % / y : % == jgfbinop("/", x, y)


    x ^ y : NonNegativeInteger ==
      jgfbinop("^", x, coerce(y pretend Integer)@JuliaInteger)
    x ^ y : PositiveInteger ==
      jgfbinop("^", x, coerce(y pretend Integer)@JuliaInteger)

    x quo y == jgfbinop("รท", x, y)
    -- x quo y == jgfbinop("div", x, y)
    x rem y == jgfbinop("%", x, y)

    if p <= convert(max()$SingleInteger)@Integer then
      q := p::SingleInteger
      recip x ==
        zero?(y := convert(x)@Integer :: SingleInteger) => "failed"
        invmod(y, q)::Integer::%
    else
      recip x ==
        zero?(y := convert(x)@Integer) => "failed"
        invmod(y, p)::%

    -- TODO
    -- Internal error: Cannot determine branch of Union.
    -- recip(x) == zero? else jgfunfunc("inv", x)

    generator() == 1
    normalElement() == 1
    createNormalElement() == 1
    characteristic() == p pretend NNI
    representationType() == "prime"
    degree(x) : PI == 1$PositiveInteger
    extensionDegree() : PI == 1$PositiveInteger
    charthRoot(x : %) : % == x
    inGroundField?(x)  == true
    coordinates(x : %) : Vector(%) == new(1, x)$(Vector %)
    represents(v)  == v(1)
    retract(x) == x
    retractIfCan(x) == x

    basis() == new(1, 1::%)$(Vector %)
    basis(n : PI) ==
      n = 1 => basis()
      error("basis: argument must divide extension degree")

    definingPolynomial() ==
      monomial(1, 1)$(SUP %) - monomial(1, 0)$(SUP %)

    minimalPolynomial(x) ==
      monomial(1, 1)$(SUP %) - monomial(x, 0)$(SUP %)

    sqrt(x) == jgfunfunc("sqrt", x)

    jlType(x)  == jlrefType(x)
    jlValue(x) == jlrefVal(x)
    jlId(x)    == jlrefId(x)
    jlRef(x)   == x pretend SExpression

    convert(x : %) : Integer == parsei string jlrefVal(x)
    coerce(x : JuliaInteger) : % ==
      jlref(concat(["GF",string(p),"(", getind(x) , ")"]))
    coerce(i : Integer) ==
      jlref(concat(["GF",string(p),"(", string(i), ")"]))
    coerce(i : %) : OutputForm == jlrefVal(i)
    jgf(i : Integer) == coerce(i)
    jgf(ji : JuliaInteger) == coerce(ji)


)abbrev domain JUP JuliaUnivariatePolynomial
++ Test package
JuliaUnivariatePolynomial(x : Symbol, R : Join(JuliaType, Ring)):
  Exports == Implementation where
    jlrefVal  ==> JLREFVAL$Lisp
    jlrefType ==> JLREFTYPE$Lisp
    jlrefId   ==> JLREFID$Lisp
    jlref     ==> make_jlref$Lisp 
    JINT      ==> JuliaInteger
    JI64      ==> JuliaInt64
    INT       ==> Integer
    PI        ==> PositiveInteger
    NNI       ==> NonNegativeInteger
    Exports ==> UnivariatePolynomialCategory(R) with
        jup     : UnivariatePolynomial(x,R) -> %
        ++ jup(p) converts the univariate polynomial p to
        ++ a Julia univariate polynomial.
        coerce  : Variable(x) -> %
        ++ coerce(x) converts the variable x to a Julia univariate polynomial.
        "*"       : (%, PositiveInteger) -> %
        "*"       : (%, NonNegativeInteger) -> %
    Implementation ==> add
        import from JuliaUtilityFunctions
        import String
    
        jlInitialize(true)
        jl_eval_string("@suppress_err using Nemo")$Lisp
        -- jlref CL class
        Rep := SExpression


        spjs(str) ==> str pretend JuliaString

        getind(a) ==> concat(["getindex(", "refs,_"", jlrefId(a), "_")"])

        upbinop(op,a,b) ==> jlref(concat([getind(a), op, getind(b)]))
        upunfunc(op, a) ==> jlref(concat([op, "(", getind(a),")"]))
        upbinbop(op,a,b) ==>
          jl_bool_eval_string(concat([getind(a), op, getind(b)]))$Lisp

        peval(expr) ==> concat(["eval(string(Meta.parse(_"",expr,"_")))"])

        --TODO: x*(1/2)...
        if R is JuliaInteger then
            jl_eval_string(concat(["R,", string(x), "=polynomial_ring(ZZ,_"",
                string(x), "_")"])$String)$Lisp
            leadingCoefficient(p : %) ==
              tmp : String := concat(["leading_coefficient(", getind(p),")"])
              jlref(tmp)
        else if R is JuliaFractionInteger then
            jl_eval_string(concat(["R,", string(x), "=polynomial_ring(QQ,_"",
                string(x), "_")"])$String)$Lisp
            leadingCoefficient(p : %) ==
              tmp : String := concat(["leading_coefficient(", getind(p),")"])
              jlref(tmp, "QQ")
        else error "Unimplemented ring."

        1 == jlref("R(1)")
        0 == jlref("R(0)")
        - a == upunfunc("-",a)
        a : % = b : % == upbinbop("==",a,b)
        a : % ~= b : % == upbinbop("!=",a,b)
        a : % + b : % == upbinop("+",a,b)
        a : % - b : % == upbinop("-",a,b)
        a : % * b : % == upbinop("*",a,b)
        i : Integer  * b : % == upbinop("*", coerce(i)@%, b)
        a : % * i : INT  == upbinop("*", a, coerce(i))
        a : % * i : PI  == upbinop("*", a, coerce(i pretend Integer)@%)
        a : % * i : NNI  == upbinop("*", a, coerce(i pretend Integer)@%)

        degree(p) == jl_int64_eval_string(concat(["degree(", getind(p),")"]))$Lisp   

        jup(up) : % ==
            p:= first(lines formatExpression(up::OutputForm)$Format1D)
            jlref(peval(p))

        coerce(v : Variable(x)) == jlref(string(v::Symbol))
        coerce(i : Integer) == jlref(concat(["R(",string(i),")"]))
        coerce(p : %) : OutputForm == jlrefVal p
